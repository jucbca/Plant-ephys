---
title: "LightPulse"
output: html_document
date: "2023-03-03"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### INPUT ".txt" file. the columns of the electrodes should have the number of the electrode. 
    E1_genotype_S#_L## where S is the electrode where the stimulus is done and L the leaf. Both are optional
### OUTPUT ".csv" file. with 8 columns: Seconds, leaf,V,genotype,Stim,Date,DayTime,id.
(3) A folder with the traces separated by power and duration in "pxsy.csv" files.
(4) "parameters_summary.csv" with the parameters and a plot for each stimulus 
(5)


1.Load all the libraries and functions. Run once
```{r}
library (ggplot2)
library (tidyr)
library(dplyr)
library(signal)
library(scales)
library(stats)
library(lubridate)
library(stringr)
# Functions
PlotTrace <- function(trace,from=0,to=max(na.omit(trace$Time)), extraInfo = "" ){
  ## Theme...
  My_Theme =  theme(
    axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
    axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
    axis.title.x = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #element_blank()
    axis.title.y = element_text(color = "black", size = 30, angle = 0, hjust = 0, vjust = 0.5, face = "plain"),
    plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "bold"), # element_blank(),#
    legend.text = element_text(size = 20),
    legend.title = element_text(hjust = 0.1, size = 20),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.major.x = element_blank(), #element_line()
    panel.grid.minor.x = element_blank()) 
  ##
  
  tracePlot <- trace %>% dplyr::filter(`Time` > from & `Time` < to ) %>% 
    ggplot(aes(`Time`, `mV`, color = `electrode`)) +
    geom_point(size = 0.5) +
    guides(color = guide_legend(override.aes = list(size = 3) )) +
    geom_vline(xintercept = stimTimes[ which(stimTimes>from & stimTimes<to) ], linewidth = 0.1 ) + #Make vertical lines the data point immediately after the stimulus pedal was hit. And that are inside the plotting time range.
    ylab ("mV") + 
    xlab ("Time (s)") + 
    labs(color = "Electrode") +
    ggtitle(paste(savename,metaData,extraInfo)) +
    My_Theme
  print(tracePlot)
  
  
  

  
}
NormalizeBaseline <- function(trace, normTime = 0 ){
  stimIndex = which(trace$Time == normTime)
  for(i in c(3:ncol(trace)) ){
    trace[,i] = trace[,i]-trace[stimIndex,i]
  } # Normalize the trace w/ the baseline. make all start at zero.
  trace = gather(trace, "electrode", "mV", 3:ncol(trace)) # change structure for ggplot management
  return(trace)
} ## INPUT trace spreaded i.e. each electrode as column. Won't work if data is not at 10Hz samplerate. Output: normalized, gathered trace for plotting.
CalculateParameters <- function(trace, stimdelay = 1){
# in the chunk during stimulation on.
  #stimdelay=0
  trace$mV = abs(trace$mV)*-1
  stimon = which(trace$TimeOfDay=="F1")[1] + stimdelay 
  stimoff= which(trace$TimeOfDay=="F1")[2] + stimdelay 
  stimchunk = na.omit(trace[stimon:(stimoff*2),])

  
          # determine maximum -peak.depol-
  
  peak.depol =  min( stimchunk$mV )
  peakdepol.frame =  max(which(trace$mV==peak.depol)-1)
  peakdepol.time =  trace$Time[peakdepol.frame]
  peakdepol.latency = peakdepol.time - trace$Time[stimon]

          # determine mean V at last 500 ms of the stimulus -ss.depol-
  stimchunk = na.omit(trace[stimon:stimoff,])    
  # plot(stimchunk$Time, stimchunk$mV, type="p") +
  #   abline(v=trace$Time[c(stimon,stimoff)],col="red") +
  #   abline(h=peak.depol)

  if ( nrow(stimchunk)>=50 ){
      ss.depol = mean( stimchunk$mV[(nrow(stimchunk)-50):nrow(stimchunk)] )
  }

  
  # in the chunk between onset of stimulus and peak.depol
  raisechunk = na.omit( trace[stimon:peakdepol.frame,] )
  # plot(raisechunk$Time, raisechunk$mV, type="p") + abline(v=trace$Time[c(stimon,stimoff)],col="red")


            # determine max.depol.slope
  # apply filter to that chunk to avoid slope peaks from noice jumps
  raisechunk.slope = calculateslope( sgolayfilt(raisechunk$mV, p=1,n=9) )
  peak.depol.slope = min(na.omit(raisechunk.slope) )
  peakdepolslope.frame = which(raisechunk.slope == peak.depol.slope ) + stimon
  peakdepolslope.time = min( trace$Time[peakdepolslope.frame] )
  peakdepolslope.latency = min( peakdepolslope.time-trace$Time[stimon] )

  plot(raisechunk.slope, type="l")
  
  
  # in the chunk after end of stimulus.
  decaychunk = na.omit(  trace[(stimoff+stimdelay) :(5*sample.rate),] ) # from end of stimulus to 5 s after. or do until end of recording wih nrow(trace) 10*sample.rate
  # gotta define the decaychunk as ending where it goes back to a maximum.
  decaychunk = na.omit(  trace[(stimoff+stimdelay) :(which(decaychunk$mV == max(decaychunk$mV))+stimoff),] ) 
  # plot(decaychunk$Time,decaychunk$mV, type="l")
          # determine time at 37% of peak.depol -tau-
  tau.voltage = round( peak.depol*0.37,2)
  tau.index = min(which( abs(decaychunk$mV- tau.voltage) == min( abs(decaychunk$mV- tau.voltage) ) ) + stimoff)
  tau.abstime = trace$Time[tau.index]
  tau = tau.abstime-trace$Time[stimoff+1]

  return(list("peak.depol"=peak.depol, 
             "peakdepol.time"=peakdepol.time, 
             "peakdepol.latency"=peakdepol.latency,
             "peak.depol.slope"=peak.depol.slope,
             "peakdepolslope.time"=peakdepolslope.time,
             "peakdepolslope.latency"=peakdepolslope.latency,
             "ss.depol"=ss.depol,
             "tau"=tau,
             "tau.abstime"=tau.abstime,
             "tau.voltage"=tau.voltage,
             "stimon" = stimon,#trace$Time[stimon+1],
             "stimoff"= stimoff)) #trace$Time[stimoff+1]))

} # input. dataframe for one pulse on one electrode 
CheckSampleRate <- function(trace){
  sampleRate = round(60/as.numeric(trace$Time[60]),1) # 60 samples in x seconds that ran in the first 60 samples. (Hz)
  if(round(sampleRate) < 10){
    print("ERROR! sample rate is not 10Hz. Quantification won't work")
  } else {
    print("Good! The sample rate is: ")
    print(paste(sampleRate, "Hz"))
  }
  return(sampleRate)
}
filterTrace <- function(trace){
  # Change NA for the value on the previous row
  NArow = which(is.na(trace$mV))
  trace$mV[NArow] = trace$mV[(E=NArow-1)] 
  # smooth with Savitzky-Golay filter. 
  # n is the amount of point befor/after the nth point to be averaged
  # p is the filter order. Dont know what that is.
  trace$mV = 
    sgolayfilt( trace$mV , p = 1, n = 9) 
  return(trace)
}
segment.trace.power1.6 <- function(trace){
    ## for later: put in a for loop.
  output = list()
          # Power 1
  # get 1 s pulse (should be the first!)
  stimulus = "p1_1s"
  cutfrom = stimTimes[1]-2 # Cuts trace 2 s before the first stimulus 
  cutto   = stimTimes[3]-10 # and 10 s after
  PlotTrace(trace, from=cutfrom, to = cutto, extraInfo = stimulus) 
  Sys.sleep(1)
  # cut out trace
  tracei = rbind( 
    trace[ which(trace$Time==round(cutfrom))[1]:which(trace$Time==round(cutto))[1], ],
    trace[ which(trace$Time==round(cutfrom))[2]:which(trace$Time==round(cutto))[2], ]
  )
  
  tracei$Stim = paste(trace$Stim[1],stimulus,sep = "_")
  output = list(tracei)
  names(output) = stimulus
  
        # get 10 s pulse (should be the second!)
  stimulus = "p1_10s"
  cutfrom = stimTimes[3]-2 # Cuts trace 2 s before the first stimulus 
  cutto   = stimTimes[5]-10 # and 10 s after
  PlotTrace(trace, from=cutfrom, to = cutto, extraInfo = stimulus)  
  Sys.sleep(1)
  # cut out trace
  tracei = rbind( 
    trace[ which(trace$Time==round(cutfrom))[1]:which(trace$Time==round(cutto))[1], ],
    trace[ which(trace$Time==round(cutfrom))[2]:which(trace$Time==round(cutto))[2], ]
  )
  
  tracei$Stim = paste(trace$Stim[1],stimulus,sep = "_")
  output[[length(output)+1]] <- tracei
  names(output)[length(output)] = stimulus
  
        # Power 6
  # get 1 s pulse (should be the third!)
  stimulus = "p6_1s"
  cutfrom = stimTimes[5]-2 # Cuts trace 2 s before the first stimulus 
  cutto   = stimTimes[7]-10 # and 10 s after
  PlotTrace(trace, from=cutfrom, to = cutto, extraInfo = stimulus) 
  Sys.sleep(1)
  # cut out trace
  tracei = rbind( 
    trace[ which(trace$Time==round(cutfrom))[1]:which(trace$Time==round(cutto))[1], ],
    trace[ which(trace$Time==round(cutfrom))[2]:which(trace$Time==round(cutto))[2], ]
  )
  
  tracei$Stim = paste(trace$Stim[1],stimulus,sep = "_")
  output[[length(output)+1]] <- tracei
  names(output)[length(output)] = stimulus
  
        # get 10 s pulse (should be the fourth!)
  stimulus = "p6_10s"
  cutfrom = stimTimes[7]-2 # Cuts trace 2 s before the first stimulus 
  cutto   = last(trace$Time) #stimTimes[8]+60 # and 10 s after
  PlotTrace(trace, from=cutfrom, to = cutto, extraInfo = stimulus) 
  Sys.sleep(1)
  # cut out trace
  tracei = rbind( 
    trace[ which(trace$Time==round(cutfrom))[1]:which(trace$Time==round(cutto)-1)[1], ],
    trace[ which(trace$Time==round(cutfrom))[2]:which(trace$Time==round(cutto)-1)[2], ]
  )
  
  tracei$Stim = paste(trace$Stim[1],stimulus,sep = "_")
  output[[length(output)+1]] <- tracei
  names(output)[length(output)] = stimulus
  return(output)
} # only for traces with stimuli in this order p1.1s,p1.10s,p6.1s,p6.10s.
calculateslope <- function(vector) {
  slopetrace = NULL
  for( i in 2:length(vector)){
    slopei = vector[i]-vector[i-1]
    slopetrace = append(slopetrace, slopei)  
  }
  slopetrace = append(slopetrace, slopetrace[length(slopetrace)])
  return(slopetrace)
} # input a 1xN vector | output a 1xN vector with values for the slope
transmission.experiment <- function(){
  # esto va antes del loop
  p1s1.trace = NULL
  p1s10.trace= NULL
  p6s1.trace = NULL
  p6s10.trace= NULL
  # Esto va depues de filtrar y plotear el registro completo
          ## Save stimulus trace
  answer <- readline (prompt="Are the stim times ok? type values divided by [,] to change, [y] to continue and save or [n] to skip trace.  ")
  while ( nchar(answer)<=15 & answer!="y" ){
    print("No valid input, try again ")
    answer <- readline (prompt="Are the stim times ok? type values divided by [,] to change, [y] to continue and save or [n] to skip trace.  ")
  }
  if( nchar(answer)>15 ){
      answer = strsplit(answer,",")[[1]]
      stimTimes = as.numeric(answer)
      print("Stim times updated to ")
      print(stimTimes)
  } else if(answer == "n"){
    next
  }
      ## Segment into the different stimuli
  segments = segment.trace.power1.6(trace)
  p1s1.trace = rbind(p1s1.trace,segments$p1_1s)
  p1s10.trace= rbind(p1s10.trace,segments$p1_10s)
  p6s1.trace = rbind(p6s1.trace,segments$p6_1s)
  p6s10.trace= rbind(p6s10.trace,segments$p6_10s)
      ##
      ## SAVE
  setwd(batchfolder)
  write.csv(p1s1.trace, "p1s1.csv", row.names = FALSE)
  write.csv(p1s10.trace, "p1s10.csv", row.names = FALSE)
  write.csv(p6s1.trace, "p6s1.csv", row.names = FALSE)
  write.csv(p6s10.trace, "p6s10.csv", row.names = FALSE)
}
segment.stimuli <- function(tracein, stimdelay = 0, minylim = -100){
  stimuli = stim.indexes
  output = list()

  for (s in seq(1,length(stimuli),2) ){ # take every second mark, so the first of every stimulus
    # first stimulus. start to first s
    delay = (stimdelay/sample.rate)*1000
    # duration of the stimulus
    stim.duration = round( ( tracein$Time[ stimuli[s+1] ] - tracein$Time[ stimuli[s] ] )*1000 )
    
    # select each electrode
    bothelectrodes = NULL
    for ( e in unique(tracein$electrode) ){
      trace.e = dplyr::filter(tracein, electrode==e)
        if ( s == 1 ){ # pick different lengths depending of the order of the pulse
        trace.singlestim = trace.e[ (stimuli[1]-(2*sample.rate)) : stimuli[3], ]
      } else if ( s == length(stimuli)-1 ) { # last stimulus. last s to end
        trace.singlestim = trace.e[ (stimuli[s]-(2*sample.rate)) : nrow(trace), ]
      } else { # all the rest
        trace.singlestim = trace.e[ (stimuli[s]-(2*sample.rate)) : (stimuli[s+2]-(1*sample.rate)) ,] # +(5*sample.rate) # this determined length of trace extracted
      }
      plot(trace.singlestim$Time, trace.singlestim$mV, type="l", ylim=rev(c(5,minylim)) ) +
      abline(v = tracein$Time[ c(stimuli[s],stimuli[s+1])+stimdelay ], col="red") +
      title(main = paste(stim.duration, "ms",sep = ""))
      Sys.sleep(1)
      # put into list
      bothelectrodes = append(bothelectrodes, list( electrode = trace.singlestim))
      names(bothelectrodes)[length(bothelectrodes)] = e
    }
    
    
    
    
    
    

    output[[length(output) + 1]] = bothelectrodes 
    names(output)[[length(output)]] = paste(stim.duration,"ms") 
  }
  return(output)
} # input complete dataframe
doFilter = 0
home = getwd()
summaryparameters = c("Genotype",
                   "record.id",
                   "electrode",
                   "stim.position",
                   "stim.power",
                   "stim.duration",
                   "peak.depol",
                   "peak.depoltime",
                   "peak.depol.slope",
                   "peakdepolslope.time",
                   "peakdepolslope.latency",
                   "ss.depol",
                   "tau")
```


2. Create a batch folder
```{r}
batchname = "240514_Analysis"
batchfolder = paste(home,batchname,sep="/")
setwd(home)
if(file.exists(batchname)==FALSE){
  dir.create(batchfolder)
}
```



3. Modify the traces in the home folder. Then the plot is divided by the stimuli. 

input   - yyy_Export.txt files in the home folder
Output  - List >savename.RData< with all the separated pulses for that recording. Traces are saved in the list in their occurrence order
```{r}
stimulusDelay = 1 # the time between light onset and the computer making the mark.
```

```{r}
setwd(home)
list.files()

recording.id = 1
for( f in list.files()[grep(".txt",list.files())] ){ # 
  filename = f
  savename = substr( filename, 0, nchar(filename)-4 )
  savename = strsplit(savename,split = "_")[[1]][1]
  trace = read.delim(  filename  ) # import .txt file in the home folder
  #trace = read.csv("array1_Export.csv"  )
  for(c in 2:ncol(trace)){
    trace[,c] = as.numeric(trace[,c])
  }
  
  sample.rate = round( CheckSampleRate(trace) )
  
  # Save info from E1 column name
  metaData = names(trace)[grep("E1", names(trace))]
  leaf = strsplit(metaData,"_")[[1]][grep("L",strsplit(metaData,"_")[[1]])]
  if(length(leaf)==0 ){
    leaf = "none"
  }
  stimulus = strsplit(metaData,"_")[[1]][grep("S",strsplit(metaData,"_")[[1]])]
  genotype = strsplit(metaData,"_")[[1]][2]
  intensity = strsplit(metaData,"_")[[1]][grep("I",strsplit(metaData,"_")[[1]])]
  intensity = substr(intensity,2,3)
  intSplit = strsplit(intensity, "")
  if ( intSplit[[1]][2] == "." ){
    intensity = 6 #as.numeric(intensity) + 6. ### Change if each pulse is in a file
  } else {
    intensity = 0 # as.numeric(intensity)
  }
  
  
  
  electrodeNums = NULL## Save the number of the electrode
  for(i in  names(trace)[3:ncol(trace)] ){
    electrodeNums = append(electrodeNums, as.numeric( substr(i,2, 2) ))
  }
  names(trace)[3:ncol(trace)] = electrodeNums # Make the columns' names numeric variables
  # Select just few electrodes.
  pickElectrodes = c(1)#c(1,2)
  trace = trace[,c(1,2,which(names(trace)%in%pickElectrodes))]
  
  
  stim.indexes =  which(trace$TimeOfDay == "F1")-1
  stimTimes = trace$Time[stim.indexes]

  which(trace$Time == 0)
  # normalize and gather
  trace = NormalizeBaseline(trace, normTime = 1)
  # fix voltage units to mV
  trace$mV = trace$mV * 100
  #
  ##
  ###
  #### NORMALIZE TRACE and plot
  trace$Genotype = genotype
  if( length(stimulus) > 0 ){
     trace$Stim = stimulus
  }
  if( length(intensity) > 0 ){
     trace$Intensity = intensity
  }
  trace$Leaf = leaf
  trace$id = recording.id # esto de donde sale?? - un contador que incrementa en cada iteracion.
  PlotTrace(trace)
  # Filter?
  answer <- readline (prompt="Filter? [y], [n]  ")
  while ( answer!="y" & answer!="n" ){
    print("No valid input, try again ")
    answer <- readline (prompt="Filter? [y], [n]  ")
  }
  if (answer == "y"){
    trace = filterTrace(trace)
    PlotTrace(trace)
    
  }
  print(paste(length(stimTimes)," stimuli at (s)",sep = ""))
  print(stimTimes)
  
  
  
  ## SAVE
  if ( length(stimTimes) > 0 ){
      # function that separates each pulse and saves everything in a list 
  trace.segmented = segment.stimuli(trace, stimdelay = stimulusDelay , minylim = -100)
  
  # save that list as a RData file.
  save(trace.segmented, file = paste(batchfolder,"/",savename, ".RData",sep = ""))
  # transmission.experiment() # runs that analysis
  } else {
    save(trace, file = paste(batchfolder,"/",savename, ".RData",sep = ""))
  }

  
  
      ##
  recording.id = recording.id+1
  setwd(home)
}
```


3.1-Pulses under different treatments.
input   - List >savename.RData< with all the separated pulses of all for that recording
Output  - same file modified with treatment information
```{r}
## Modify according to experiment!
treatment = "flg22-10mM"
pulses.per.round = 3
```

```{r}
setwd(batchfolder)
# load data
f = list.files()[grep(".RData", list.files()) ]
load( f )
# label each pulse treatment and round.
if(length(trace.segmented)%%pulses.per.round != 0){
  print("Number of traces not multiple of the pulses per round!")
}
for(i in c(1:3)){
  trace.segmented[[i]][[1]]$Treatment = "baseline"
  trace.segmented[[i]][[2]]$Treatment = "baseline"
  trace.segmented[[i]][[1]]$Treatment.time = 0
  trace.segmented[[i]][[2]]$Treatment.time = 0
}
time.initial = period_to_seconds(hms( trace.segmented[[1]][[1]]$TimeOfDay[1] )) 
counter = 1
for(i in c(4:length(trace.segmented)) ){
  if(counter <= 3){
    if(counter==1){
      time.pulse =round (period_to_seconds(hms(trace.segmented[[i]][[1]]$TimeOfDay[1])) -
        time.initial ,0 ) 
    }
    trace.segmented[[i]][[1]]$Treatment = treatment
    trace.segmented[[i]][[2]]$Treatment = treatment
    trace.segmented[[i]][[1]]$Treatment.time = time.pulse
    trace.segmented[[i]][[2]]$Treatment.time = time.pulse
    print(time.pulse)
    counter = counter + 1
  }
  if(counter > 3){
    counter = 1
  }
}
# save that list as a RData file.
savename = substr(f,1,(nchar(f)-6))
save(trace.segmented, file = paste(batchfolder,"/",savename, ".RData",sep = ""))
```



4. Analyze - calculate raising slope, peak depol, steady state depol, and tau.
input   -  >genotype.RData< traces in the batch folder. The list is called "trace.segmented". Analyze some or all the pulse in the file.
output  - datasummary saved as "parameters_summary.csv" for each stimulus the calculated parameters, for all the electrodes in the file. 
  peak.depol - max depolarization
  peak.depol.slope - raising time of depolarization upon simulus
  peakdepolslope.time - time at which depol slope is max
  ss.depol - depolarization in the last second.
  tau - time at which voltage is 37% of the peak.depol after the stimulus ends.
```{r}
## INPUT REQUIRED HERE!!
# Analyze all pulses or just one of them?
pulse.from = 1# start at which pulse?
pulse.to = 1 # 1,2,3rd. input the number. or length(names(trace.segmented)) to do ALL.

####
setwd(batchfolder)
if(file.exists( paste(batchfolder,"/PulsePlots",sep=""))==FALSE){
  dir.create( paste(batchfolder,"/PulsePlots",sep=""))
}
# make for loop for all the files
files =list.files()[grep("RData",list.files())]
datasummary = NULL
for(f in files){
  load(f)
  print(f)
  # separate stim info into columns
  # If there is cut information- save
  if( length(grep("cut",f)) != 0  ){
    petiol.state = strsplit(f, "-")[[1]][2]
    petiol.state <- substr(petiol.state, 1, (nchar(petiol.state)-6) )
  } 
  
  # loop through every one stimulus or pulse with all the available electrodes
  for(i in pulse.from:pulse.to ){
    print(paste("stimulus #",i,"-",names(trace.segmented)[i]))
    # Loop through electrodes
    for(e in names(trace.segmented[[i]]) ){ #c(1) names(trace.segmented[[i]])
      onepulse = trace.segmented[[i]][[e]]
      savename = paste( substr(f,1,nchar(f)-6),"#",i,"_e",onepulse$electrode[1],"_",onepulse$Stim[1],"_",onepulse$Leaf[1], sep = "" )

      
      
    # fix time and V offset
    onepulse$Time = onepulse$Time-onepulse$Time[which(onepulse$TimeOfDay=="F1")[1]+1+stimulusDelay] # set the stimulus onset as time = 0 
    onepulse$mV = onepulse$mV - mean(na.omit(onepulse$mV[1:(which(onepulse$TimeOfDay=="F1")[1]-10)]))  # set the voltage baseline as 0
    plot(onepulse$Time,onepulse$mV)+
  abline(v=onepulse$Time[which(onepulse$TimeOfDay=="F1")+1], col="red")
    
          # determine plot x limits
      from = which(round(onepulse$Time,1)==(-1))[1]
      to =  nrow(onepulse) #  which(round(onepulse$Time,1)== 10)[1] #  round(parameters$tau.abstime))[1]+100 #nrow( onepulse)
        #
     
    
# if trace's absolut max peak is less than 2mV in amplitude:
   if( min( abs( onepulse$mV[which(onepulse$TimeOfDay=="F1")[1]+stimulusDelay:
                          which(onepulse$TimeOfDay=="F1")[2]+stimulusDelay] )*-1 ) - mean( onepulse$mV[1:which(onepulse$TimeOfDay=="F1")[1]+stimulusDelay] ) > -0.0001 ) {
 # plot
    plot(onepulse$Time[from:to], 
         onepulse$mV[from:to], 
         main=savename, 
         #ylim=c(-2,2),
         cex=0.5,
         type= "l") + 
    abline(v=onepulse$Time[which(onepulse$TimeOfDay=="F1")+stimulusDelay],col="green")
    answer <- readline (prompt="Save plot and data? [y] to save, [n] to skip trace and not save ")
    while ( nchar(answer)!=1 ){
      print("No valid input, try again ")
      answer <- readline (prompt="Save plot and data? [y] to save, [n] to skip trace and not save ")
    }
    if( answer == "y" ){
      pdf(file = paste( batchfolder,"/PulsePlots/",savename,".pdf" , sep = "") )
      
            plot(onepulse$Time[from:to], 
         onepulse$mV[from:to], 
         main=savename, 
         ylim=c(-2,2),
         cex=0.5,
         type= "l") + 
    abline(v=onepulse$Time[which(onepulse$TimeOfDay=="F1")+stimulusDelay],col="green")
        
      dev.off()
      
    } else if(answer == "n"){
      next
    }
   }
    else {
              # calculate parameters
      parameters = CalculateParameters(onepulse,stimdelay = stimulusDelay)
      parameters[which(is.na(parameters)==TRUE)] <- 0
      
      
              # plot trace
      plot(onepulse$Time[from:to], 
           onepulse$mV[from:to], 
           main=savename, 
           #ylim=c(-100,5),
           cex=0.5,
           type= "l") + 
      abline(v=onepulse$Time[which(onepulse$TimeOfDay=="F1")+1+stimulusDelay],col="green")+
      abline(v=parameters$peakdepolslope.time, col="magenta", lty=1)+
      abline(v=parameters$tau.abstime, col="blue", lty=1)+
      abline(h=parameters$peak.depol, col="magenta", lty=1)+
      abline(h=parameters$ss.depol, col="red", lty=1) +
      abline(h=parameters$tau.voltage, col="blue", lty=2)  
      
       print(parameters[c(1,5,6,7,8)])
      ## Save stimulus trace
      answer <- readline (prompt="Save plot and data? [y] to save, [n] to skip trace and not save ")
      while ( nchar(answer)!=1 ){
        print("No valid input, try again ")
        answer <- readline (prompt="Save plot and data? [y] to save, [n] to skip trace and not save ")
      }
      if( answer == "y" ){
        pdf(file = paste( batchfolder,"/PulsePlots/",savename,".pdf" , sep = "") )
        
          plot(onepulse$Time[from:to], 
           onepulse$mV[from:to], 
           main=savename, 
           #ylim=c(-100,5),
           cex=0.5 ,
           type= "l") +
        abline(v=onepulse$Time[which(onepulse$TimeOfDay=="F1")+1+stimulusDelay],col="green")+
        abline(v=parameters$peakdepolslope.time, col="magenta", lty=1)+
        abline(v=parameters$tau.abstime, col="blue", lty=1)+
        abline(h=parameters$peak.depol, col="magenta", lty=1)+
        abline(h=parameters$ss.depol, col="red", lty=1) +
        abline(h=parameters$tau.voltage, col="blue", lty=2)  
          
        dev.off()
        datasummary = rbind( datasummary, 
                       cbind( i,
                              petiol.state,
                              onepulse$Leaf[1],
                              #onepulse$Stim[1],
                              onepulse[1,which( names(onepulse) %in% summaryparameters)] ,
                              parameters[which(names(parameters) %in% summaryparameters)] )
                      ) 
        write.csv(datasummary,"parameters_summary.csv",row.names = FALSE)
        
      } else if(answer == "n"){
          next
        }
      }
    }
    files = files[-(which(files==f))]
  } 
}
```




4'. Dose-Response (intensity vs amplitude) Calculate parameters

4.1
Define the power of the different intensities with a dictionary. Then modify the >savename.RData< file in step 4.2
```{r}
intensity.values = c("0.5" = 0.03,
                     "1" = 0.06,
                     "2" = 0.13,
                     "3" = 0.22,
                     "4" = 0.48,
                     "5" = 0.99,
                     "6" = 1.19,
                     "6.5" = 26.33,
                     "7" = 52.63,
                     "8" = 114.10,
                     "9" = 186.8,
                     "10" = 458.33,
                     "11" = 881,
                     "12" = 1047.67 )
```
4.2
input   -  >savename.RData< traces separated by pulses, "intensity.values" variable defined in 4.1
output  - datasummary.csv file with all the intensities for the same plant.
```{r}
setwd(batchfolder)
if(file.exists( paste(batchfolder,"/PulsePlots",sep=""))==FALSE){
  dir.create( paste(batchfolder,"/PulsePlots",sep=""))
}

#load(list.files()[1])

trace.joint = NULL #data.frame( "Time" = trace.segmented[[1]]$'1'$Time)
# Loop through all first traces. provisional!
for( f in grep("RData",list.files()) ){ # go through the lists of the different experiment
  print(list.files()[f])
  load(list.files()[f])
  print(length(trace.segmented))
  trace.joint = append( trace.joint, trace.segmented)
}
savename = substr(list.files()[f], 1, 5) 
save(trace.joint, file = paste(batchfolder,"/",savename, "-joint.RData",sep = ""))



# Set the intensities of all pulses. Increases every 4 pulses. and Pick each 4th pulse. and analyze!
index4 = 1
index.intensity = 1
trace.compilation = NULL
datasummary = NULL
for( i in 1:(4*length(intensity.values)) ) {
  print(index4)
  trace.joint[[i]]$'1'$Intensity = intensity.values[index.intensity]
  # keep 1st trace of that intensity for analysis
  if ( index4 == 1){ 
      # normalize time to start at 0 for that pulse
    trace.joint[[i]]$'1'$Time = trace.joint[[i]]$'1'$Time-trace.joint[[i]]$'1'$Time[1]
      # normalize voltage to that 1 s before the pulse
    trace.joint[[i]]$'1'$mV = trace.joint[[i]]$'1'$mV - 
      trace.joint[[i]]$'1'$mV[ which(trace.joint[[i]]$'1'$TimeOfDay  == "F1")-10 ][1]
      # extract and save analyzed data
    datasummary = rbind(datasummary,
                    cbind( as.data.frame( CalculateParameters( trace.joint[[i]]$'1',stimdelay=1) ),
                           "Intensity" = trace.joint[[i]]$'1'$Intensity[1],
                           "Leaf" =trace.joint[[i]]$'1'$Leaf[1],
                           "id" = trace.joint[[i]]$'1'$id[1],
                           "Genotype" = trace.joint[[i]]$'1'$Genotype[1] ) 
                    )
      # plot pulse and save
    pdf( paste(batchfolder,"/PulsePlots/",savename,"-",names(intensity.values)[index.intensity],".pdf",sep="") )
      plot(trace.joint[[i]]$'1'$Time , trace.joint[[i]]$'1'$mV, "l") +
        abline(h = datasummary$peak.depol[index.intensity], col="green" ) +
        abline(v = datasummary$tau.abstime[index.intensity], col="red" ) +
        abline(h = datasummary$tau.voltage[index.intensity], col="red" ) +
        abline(v = (datasummary$stimon[index.intensity]/sample.rate), col="green" ) +
        abline(v = (datasummary$stimoff[index.intensity]/sample.rate), col="green" ) 
    dev.off()
    trace.compilation = append( trace.compilation, 
                                trace.joint[[i]] )
    names(trace.compilation)[ length(trace.compilation) ] <-  intensity.values[index.intensity]
    print(names(trace.compilation)[ length(trace.compilation) ] )
  }
  
  index4 = index4 + 1
  if(index4 > 4 ){ 
    index4 = 1
    index.intensity = index.intensity + 1 
  }
}

# save datasummary
write.csv(datasummary, "Col0-1-datasummary.csv", row.names = FALSE)

### Plot overlay of pulses
trace.plot = data.frame()
for( i in 1:length(trace.compilation)){
  trace.plot = rbind(trace.plot,
                     cbind("Time"=trace.compilation[[i]]$Time, 
                           "mV" = trace.compilation[[i]]$mV, 
                           "Intensity" = trace.compilation[[i]]$Intensity ))
}

ggplot( trace.plot, aes(Time, mV, group = Intensity, color = Intensity) )+ #dplyr::filter(trace.compilation, Intensity==c(1,2))
  geom_line() + 
  scale_color_gradient( low="black", high="darkorange") +
  # add stim:
  geom_vline(xintercept = trace.compilation$Time [which( is.na(trace.compilation$Time) == TRUE )+10][1:2], color = "darkolivegreen3", linetype = "dashed" ) +
  labs (x = "seconds", color = "µW/mm2") + 
  ggtitle( paste(datasummary$Genotype[1],datasummary$Leaf[1],datasummary$id[1] ) ) +
  
  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #element_blank(), #
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_blank(),
  panel.grid.minor.y = element_line(),
  panel.grid.major.x = element_blank(), #element_blank(), #element_line()
  panel.grid.minor.x = element_blank()) 
ggsave( paste( savename, ".pdf", sep = "" ) )


```

5'. Genetic background - ACR1 construct comparison.
input - A "parameters_summary.csv" file with all analyzed statistics
output- 

```{r}
setwd(home)
datasummary = read.csv( "KOlines.datasummary.csv" )
# Comparte the following parameters 
parameters = c( "peak.depol",    
                "peak.depol.slope"  ,  
                #"peakdepolslope.latency" ,
                #"ss.depol"   ,        
                "tau"       )
# scatter plot for parameters comparing genotypes and ACR1 constructs
head(datasummary)

# organize genotype and ACR1 construct expressed
genotype = c()
acr1 = c()
for(i in 1:nrow(datasummary)){
  genotype = rbind( genotype,
                    substr(datasummary$Genotype[i],1,(nchar(datasummary$Genotype[i])-4) )
  )
  acr1 = rbind(acr1, 
               substr(datasummary$Genotype[i],(nchar(datasummary$Genotype[i])-2),nchar(datasummary$Genotype[i]))
  )
}
datasummary$Genotype = as.vector( genotype )
datasummary$ACR1 = as.vector( acr1 )

datasummary = datasummary[-c(which(datasummary$ACR1=="001")),]  # tst
#datasummary %>% dplyr::filter(ACR1 == c("026","030") ) 
datasummary = datasummary[-c(which(datasummary$Genotype =="slah3.1")),]
# plot now
for(v in names(datasummary)[names(datasummary) %in% parameters ] ){
  print(v)
  plot <- 
    ggplot( datasummary, aes(Genotype, datasummary[,v], color = ACR1 ) ) +
    geom_point(position = position_jitter(0.2), size = 3 ) +
    labs (y = v) + 
    ggtitle( "530nm - 1050µW/mm2 - 1s" ) +
    theme(
    axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
    axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
    axis.title.x = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #element_blank(), #
    axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
    plot.title = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
    legend.text = element_text(size = 20),
    legend.title = element_text(hjust = 0.1, size = 20),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_line(),
    panel.grid.major.x = element_blank(), #element_blank(), #element_line()
    panel.grid.minor.x = element_blank()) 
  print(plot) 
  ggsave( paste( "KOs-026.030_",v, ".pdf", sep = "" ) )
}


```




 5. Run statistics! Decide which ones you want to run


5.0. Plot the dose response curve from the datasummary.csv file from 4'
input   - datasummary.csv file with all the parameters for each stimulus
output  - Plot of calculated variables vs the duration of the stimulus in log scale
```{r}
# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #element_blank(), #
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.x = element_line(), #element_blank(), #element_line()
  panel.grid.minor.x = element_line()) 

head(datasummary)
parameters2plot = c("peak.depol",
                    "peakdepolslope.latency",
                    "tau",
                    "peak.depol.slope") 
# "ss.depol",
#                     "peakdepol.latency",
#                     "peak.depol.slope",
for( v in which(names(datasummary)%in%parameters2plot) ){
figure <-   
  ggplot(dplyr::filter(datasummary), aes(`Intensity`, datasummary[,v], color = `Leaf` )) +
  geom_point(size = 3) +
  scale_x_continuous(trans='log10',
                     breaks=c(1,10,100,1000,10000) #trans_breaks('log10', function(x) 10^x),
                     ) +
  #xlim(c(1,5)) +
  xlab ("log10 Power density 535nm light (µW/mm2)") + 
  ylab (names(datasummary)[v]) + 
  ggtitle("Dose-response") +
  My_Theme
print(figure)
ggsave(paste(home,"/DoseResponse-",names(datasummary)[v],".pdf",sep = "") )
}



setwd(home)
```

5.1 Compare parameters between genotypes, positions or electrodes
input   -   datasummary.csv
output  - "datastats.csv" with mean, SEM, shapiro, and whitney-mann tests for tau data. All that plotted and saved as Transmission-<variable>.pdf and Local.response-<variable>.pdf
```{r}
setwd(batchfolder)
# pick values where stimulus is applied on the recording electrode
# onelectrode.data = datasummary %>% slice(which(datasummary$position %>% substr(2,2) %>% as.integer() == datasummary$electrode))
# set position column
datasummary = read.csv( "KOlines.datasummary.csv" )
position = c()
for( i in 1:nrow(datasummary)) {
  if ( length( grep( datasummary$electrode[i] ,  datasummary$`onepulse.Stim.1.`[i]) ) == 1 ){
    position = append(position, "Local")
  } else {
    position = append(position, "Distal")
  }
}
datasummary$position = position

# run statistics on the tau, 
parameters = c( "peak.depol",
                "peakdepol.latency" ,    
                "peak.depol.slope"  ,  
                "peakdepolslope.latency" ,
                #"ss.depol"   ,        
                "tau"       ,          
                "tau.abstime"     ,    
                "tau.voltage")

datastats = NULL
# statisticaly compare local to distal.
for(g in unique(datasummary$Genotype) ){
    for(v in names(datasummary)[names(datasummary) %in% parameters ] ){
      first.data = datasummary %>% dplyr::filter(position == "Local" & 
                                    i == 1) %>%
        select(all_of(v))
      
      first.data = na.omit(first.data[,1])  
      
      second.data = datasummary %>% dplyr::filter( position == "Distal" & 
                                    i == 2) %>%
        select(all_of(v))
      second.data = na.omit(second.data[,1])
    
      first.mean = first.data %>% mean() %>% round(2)
      second.mean = second.data %>% mean() %>% round(2)
      
      first.n = length(first.data)
      second.n = length(second.data)
      
      first.SEM = ((first.data %>% sd() ) / first.n)%>%round(2)
      second.SEM = ((second.data %>% sd() ) / second.n)%>%round(2)
      
      first.shapiro = shapiro.test(first.data)$p.value%>%round(3)
      second.shapiro = shapiro.test(second.data)$p.value%>%round(3)
      
      WM = wilcox.test(first.data,second.data)$p.value%>%round(4)
      
      T.tst = t.test(first.data,second.data)$p.value%>%round(4)
    
      
      datastats = rbind(datastats,
                            data.frame("genotype"=g,
                                       "variable" = v,
                                     first.mean,
                                      second.mean,
                                      first.SEM,
                                       second.SEM,
                                      first.n,
                                       second.n,
                                      first.shapiro,
                                      second.shapiro,
                                       "Whitney-Mann"=WM,
                                      "t.test"= T.tst))
  }
}

write.csv(datastats, "datastats.csv", row.names = FALSE)


# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_blank(), #element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #
  axis.title.y = element_text(color = "black", size = 20, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.x = element_blank(), #element_line()
  panel.grid.minor.x = element_blank(),
  panel.background =  element_blank()) 

parameters2plot = c( "peak.depol",
                #"peakdepol.latency"    
                # "peak.depol.slope"  ,  
                "peakdepolslope.time" ,
                #"ss.depol"   ,        
                "tau"       
                )

### DO specific analysis


# compare local vs distal response in precut and postcut
local.datasummary = dplyr::filter(datasummary, `position` == "Local" ) #  datasummary#dplyr::filter(datasummary, `position` == "Distal" ) #  dplyr::filter(datasummary, `position` == "Distal" ) #
for(v in which(names(local.datasummary)%in%parameters2plot ) ){
  n = nrow(dplyr::filter(local.datasummary, `onepulse.Leaf.1.` == "L13"))
  petiole = local.datasummary %>% dplyr::filter( `onepulse.Leaf.1.` == "L13" ) %>%
            select(all_of(names(datasummary)[v]))
  petiole = petiole[,1]
  leaf.base =  local.datasummary %>% dplyr::filter( `onepulse.Leaf.1.` == "L08" ) %>%
        select(all_of(names(datasummary)[v])) 
  leaf.base = leaf.base[,1]
  
  MW = wilcox.test(petiole,leaf.base)$p.value %>% round(3)
  
  
  ggplot(local.datasummary, aes(`onepulse.Leaf.1.`, local.datasummary[,v])) +
  geom_boxplot(linewidth = 1) +
  #geom_dotplot(binaxis='y', stackdir='center', position=position_dodge(0.9),dotsize=0.5,aes(fill=`Genotype`)) +
  geom_jitter(shape=1, position=position_dodge(0.9), size = 5, stroke = 0.7) +
  #scale_colour_gradient(low="darkorchid1",high="limegreen") + 
  stat_summary(fun="mean")+
  stat_summary(fun.data=mean_se, geom="errorbar", color="black", width=0.1)+
  ylab (names(local.datasummary)[v]) + 
  #ylim(-90,0) +
  ggtitle( paste("535nm on Col-0:ACR1 n=",n," MW p.val=",MW,sep="") ) +
  My_Theme
  
  ggsave( paste("Localleaf.response-",names(local.datasummary)[v],".pdf",sep = "") ) 
} 

# Compare local to distal recordings

for(v in which(names(datasummary)%in%parameters2plot ) ){
  n = nrow(dplyr::filter(datasummary, `position`=="Local"))
  local.data = datasummary %>% dplyr::filter(`position`=="Local") %>%
            select(all_of(names(datasummary)[v]))
  local.data = local.data[,1]
  distal.data =  datasummary %>% dplyr::filter(`position`== "Distal") %>%
        select(all_of(names(datasummary)[v])) 
  distal.data = distal.data[,1]
  
  MW = wilcox.test(local.data, distal.data)$p.value %>% round(3)

  
  ggplot(datasummary, aes(`position`, datasummary[,v], color = `stim.duration.ms.`)) +
  geom_violin(linewidth = 1) +
  #geom_dotplot(binaxis='y', stackdir='center', position=position_dodge(0.9),dotsize=0.5,aes(fill=`Genotype`)) +
  geom_jitter(shape=1, position=position_dodge(0.9), size = 5, stroke = 0.7 ) +
  scale_colour_gradient(low="darkorchid1",high="limegreen") +
  stat_summary(fun="mean")+
  stat_summary(fun.data=mean_se, geom="errorbar", color="black", width=0.1)+
  ylab (names(datasummary)[v]) + 
  ggtitle( paste("535nm on Col-0:ACR1 n=",n," MW p.val=",MW,sep="") ) +
  My_Theme
  
  ggsave( paste("Transmission-",names(datasummary)[v],".pdf",sep = "") ) 
}



# Compare local to distal recordings w/o the first stimulus

latter.datasummary = datasummary[ -(c(seq(1,nrow(datasummary),10),seq(2,nrow(datasummary),10))) ,]
for(v in which(names(latter.datasummary)%in%parameters2plot ) ){
  n = nrow(dplyr::filter(latter.datasummary, `position`=="Local"))
  local.data = latter.datasummary %>% dplyr::filter(`position`=="Local") %>%
            select(all_of(names(latter.datasummary)[v]))
  local.data = local.data[,1]
  distal.data =  latter.datasummary %>% dplyr::filter(`position`== "Distal") %>%
        select(all_of(names(latter.datasummary)[v])) 
  distal.data = distal.data[,1]
  
  MW = wilcox.test(local.data, distal.data)$p.value %>% round(3)

  
  ggplot(latter.datasummary, aes(`position`, latter.datasummary[,v], color = `stim.duration.ms.`)) +
  geom_violin(linewidth = 1) +
  #geom_dotplot(binaxis='y', stackdir='center', position=position_dodge(0.9),dotsize=0.5,aes(fill=`Genotype`)) +
  geom_jitter(shape=1, position=position_dodge(0.9), size = 5, stroke = 0.7 ) +
  scale_colour_gradient(low="darkorchid1",high="limegreen") +
  stat_summary(fun="mean")+
  stat_summary(fun.data=mean_se, geom="errorbar", color="black", width=0.1)+
  ylab (names(latter.datasummary)[v]) + 
  ggtitle( paste("535nm on Col-0:ACR1 n=",n," MW p.val=",MW,sep="") ) +
  My_Theme
  
  ggsave( paste("Transmission.latterStim-",names(latter.datasummary)[v],".pdf",sep = "") ) 
}

```

5- tests for treatments data. average and compare parameters of responses over time.
input   -   datasummary.csv
output  - 
```{r}
# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #element_blank(), #
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.x = element_line(), #element_blank(), #element_line()
  panel.grid.minor.x = element_line()) 

head(datasummary)
parameters2plot = c("peak.depol",
                    "peak.depol.slope",
                    "tau")
for( v in which(names(datasummary)%in%parameters2plot) ){
figure <-   ggplot(dplyr::filter(datasummary), aes(time.treatment, datasummary[,v], color = `position` )) +
  geom_point(size = 3) +

  #xlim(c(1,5)) +
  xlab ("time after treatment (s)") + 
  ylab (names(datasummary)[v]) + 
  ggtitle(paste( unique(datasummary$treatment)[2]," treatment", " Power-1", sep="") ) +
  My_Theme
print(figure)
ggsave(paste(batchfolder,"/Treatment-",names(datasummary)[v],".pdf",sep = "") )
}

# Group by time after treatment

head(datasummary)
datasummary %>% group_by(time.treatment) %>% summarise(mean(peak.depol))
```








___________

5.2 Compare amplitude between electrodes
input   - 
output  - 
```{r}
setwd(batchfolder)
# create columns that determines which recording is of local stimulus and whichdistal
datasummary = read.csv("parameters_summary.csv")
datasummary$local.stim = NaN

datasummary = rbind( 
  datasummary %>% slice(which(datasummary$stim.position %>% substr(2,2) %>% as.integer() == datasummary$electrode)) %>% mutate(local.stim="0mm"),
  datasummary %>% slice(which(datasummary$stim.position %>% substr(2,2) %>% as.integer() != datasummary$electrode)) %>% mutate(local.stim="6mm") 
)

# work only with Col0 data for now
g = "SLAH3"
datasummary.g = datasummary%>%dplyr::filter(Genotype==g)
parameters = c("peak.depol", "peak.depol.slope", "ss.depol")
for( v in which( names(datasummary.g)%in%parameters ) ) {
  print(names(datasummary.col0)[v])
  units = "Voltage (mV)"
  if(names(datasummary.g)[v]=="peak.depol.slope"){
    units = "Slope (mV/s)"
  }
  plotName = paste(g," - ", names(datasummary.g)[v], sep = "")
  traceParamPlot <- 
    ggplot(datasummary.g, aes(`local.stim`, datasummary.g[,v], color = `stim.duration`, lty = `stim.power` )) +
      geom_violin(size = 1) + 
      #geom_dotplot(binaxis='y', stackdir='center', position=position_dodge(0.9),dotsize=0.5,aes(fill=`Genotype`)) +
      geom_jitter(shape=1, position=position_dodge(0.9), size = 3) +
      # geom_label(data = datastats ,
      #            aes(label = `Whitney.Mann`, y = Inf), inherit.aes = TRUE, 
      #           position=position_dodge(1), vjust = 1.5 ) +
      ylab (units) + 
      ggtitle(plotName) +
      My_Theme
  print(traceParamPlot)
  ggsave(paste(plotName,".pdf",sep=""),traceParamPlot )
  Sys.sleep(0.2)
}
```

5.3 Compare raising time between electrodes RUN MANUALLY!
```{r}
library(plyr)
list.files()
data = read.csv("datasummary.csv"  )
data$stim.duration.ms.
data$stim.duration.ms. = as.character(round_any(data$stim.duration.ms, 100))

ggplot(data, aes(`stim.duration.ms.`, `peakdepolslope.time`, color=`electrode`))+
  #geom_violin(size = 1) + 
      geom_dotplot(binaxis='y', stackdir='center', position=position_dodge(0.9),dotsize=0.5,aes(fill=`electrode`))+
      #geom_jitter(shape=1, position=position_dodge(0.9), size = 3) +
      # geom_label(data = datastats ,
      #            aes(label = `Whitney.Mann`, y = Inf), inherit.aes = TRUE, 
      #           position=position_dodge(1), vjust = 1.5 ) +
      ylab ("Depol rate peak (ms)") + 
      xlab ("Depol rate peak (ms)") + 
      ggtitle("Time to raise vs Stim duration") +
      My_Theme
ggsave("depolarizationRate.pdf")



# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), #
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.x = element_blank(), #element_line()
  panel.grid.minor.x = element_blank()) 
```

By hand statistical tests:
```{r}

dataset1 = datasummary %>% dplyr::filter(stim.duration.ms. <= 100 & 
                                    position == "Distal") %>%
        select(all_of("peak.depol"))

dataset2 =  datasummary %>% dplyr::filter(stim.duration.ms. > 5000 & 
                                    position == "Distal") %>%
        select(all_of("peak.depol"))

dataset1 = na.omit(dataset1[,1])
dataset2 = na.omit(dataset2[,1])
shapiro.test(dataset1)$p %>% round(3)

# non parametric
test = wilcox.test(dataset1, dataset2)

# parametric 
test = t.test( dataset1, dataset2,
       alternative = c("two.sided"),
       mu = 0, paired = FALSE, var.equal = FALSE,
       conf.level = 0.95 )

#SAVE ALL STATS
handMade.stats = data.frame( test$method,
                             test$statistic,
                             test$p.value,
                             "firstStim-mean" = mean(dataset1),
                             "firstStim-SEM" = sd(dataset1)/length(dataset1),
                             "laterStims-mean" = mean(dataset2),
                             "laterStims-SEM" = mean(dataset2))

write.csv(file = "DoseResponse-peak.depol-StatsDistal.csv", handMade.stats, row.names = FALSE)
```

