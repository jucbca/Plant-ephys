---
title: "LightPulse"
output: html_document
date: "2023-03-03"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### INPUT ".txt" file. the columns of the electrodes should have the number of the electrode.
### OUTPUT ".csv" file. with 8 columns: Seconds, leaf,V,genotype,Stim,Date,DayTime,id.
??



1.Load all the libraries and functions. Run once
```{r}
library (ggplot2)
library (tidyr)
library(dplyr)
library(signal)
# Functions
PlotTrace <- function(trace,from=0,to=max(na.omit(trace$Time)), extraInfo = "" ){
  ## Theme...
  My_Theme =  theme(
    axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
    axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
    axis.title.x = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #element_blank()
    axis.title.y = element_text(color = "black", size = 30, angle = 0, hjust = 0, vjust = 0.5, face = "plain"),
    plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "bold"), # element_blank(),#
    legend.text = element_text(size = 20),
    legend.title = element_text(hjust = 0.1, size = 20),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.major.x = element_blank(), #element_line()
    panel.grid.minor.x = element_blank()) 
  ##
  
  tracePlot <- trace %>% dplyr::filter(`Time` > from & `Time` < to ) %>% 
    ggplot(aes(`Time`, `mV`, color = `electrode`)) +
    geom_point(size = 0.5) +
    guides(color = guide_legend(override.aes = list(size = 3) )) +
    geom_vline(xintercept = stimTimes[ which(stimTimes>from & stimTimes<to) ], linewidth = 0.1 ) + #Make vertical lines the data point immediately after the stimulus pedal was hit. And that are inside the plotting time range.
    ylab ("mV") + 
    xlab ("Time (s)") + 
    labs(color = "Electrode") +
    ggtitle(paste(savename,metaData,extraInfo)) +
    My_Theme
  print(tracePlot)
  
  
  

  
}
NormalizeBaseline <- function(trace, normTime = 0 ){
  stimIndex = which(trace$Time == normTime)
  for(i in c(3:ncol(trace)) ){
    trace[,i] = trace[,i]-trace[stimIndex,i]
  } # Normalize the trace w/ the baseline. make all start at zero.
  trace = gather(trace, "electrode", "mV", 3:ncol(trace)) # change structure for ggplot management
  return(trace)
} ## INPUT trace spreaded i.e. each electrode as column. Won't work if data is not at 10Hz samplerate. Output: normalized, gathered trace for plotting.
CalculateParameters <- function(trace){
# in the chunk during stimulation on.
  stimon = which(trace$TimeOfDay=="F1")[1]
  stimoff= which(trace$TimeOfDay=="F1")[2]
  stimchunk = na.omit(trace[stimon:stimoff,])
  #plot(stimchunk$Time, stimchunk$mV) 
          # determine maximum -peak.depol-
  peak.depol =  min( stimchunk$mV )
  peakdepol.frame =  which(trace$mV==peak.depol)-1
  peakdepol.time =  trace$Time[peakdepol.frame]
          # determine mean V at last 500 ms of the stimulus -ss.depol-
  ss.depol = mean( stimchunk$mV[(nrow(stimchunk)-50):nrow(stimchunk)] )
  #plot(stimchunk$Time[(nrow(stimchunk)-50):nrow(stimchunk)], stimchunk$mV[(nrow(stimchunk)-50):nrow(stimchunk)])
  
  
  # in the chunk between onset of stimulus and peak.depol
  raisechunk = na.omit( trace[stimon:peakdepol.frame,] )
            # determine max.depol.slope
  raisechunk.slope = calculateslope(raisechunk$mV)
  peak.depol.slope = min(na.omit(raisechunk.slope) )
  peakdepolslope.frame = which(raisechunk.slope == peak.depol.slope ) + stimon
  peakdepolslope.time = trace$Time[peakdepolslope.frame]
  #plot(raisechunk.slope)
  
  
  # in the chunk after end of stimulus.
  decaychunk = na.omit(  trace[stimoff:nrow(trace),] )
  #plot(decaychunk$Time,decaychunk$mV)
          # determine time at 37% of ss.depol -tau-
  tau.voltage = round(ss.depol*0.37,2)
  tau.index = which( abs(decaychunk$mV- tau.voltage) == min( abs(decaychunk$mV- tau.voltage) ) ) + stimoff
  tau.abstime = trace$Time[tau.index]
  tau = tau.abstime-trace$Time[stimoff+1]

  return(list("peak.depol"=peak.depol, 
             "peakdepol.time"=peakdepol.time, 
             "peak.depol.slope"=peak.depol.slope,
             "peakdepolslope.time"=peakdepolslope.time,
             "ss.depol"=ss.depol,
             "tau"=tau,
             "tau.abstime"=tau.abstime,
             "tau.voltage"=tau.voltage))

} # input. dataframe for one pulse on one electrode 
CheckSampleRate <- function(trace){
  sampleRate = round(60/trace$Time[60],1) # 60 samples in x seconds that ran in the first 60 samples. (Hz)
  if(round(sampleRate) <= 10){
    print("ERROR! sample rate is not 10Hz. Quantification won't work")
  } else {
    print("Good! The sample rate is: ")
    print(paste(sampleRate, "Hz"))
  }
}
filterTrace <- function(trace){
  # Change NA for the value on the previous row
  NArow = which(is.na(trace$mV))
  trace$mV[NArow] = trace$mV[(E=NArow-1)] 
  # smooth with Savitzky-Golay filter. 
  # n is the amount of point befor/after the nth point to be averaged
  # p is the filter order. Dont know what that is.
  trace$mV = 
    sgolayfilt( trace$mV , p = 1, n = 9) 
  return(trace)
}
segment.trace <- function(trace){
    ## for later: put in a for loop.
  output = list()
          # Power 1
  # get 1 s pulse (should be the first!)
  stimulus = "p1_1s"
  cutfrom = stimTimes[1]-2 # Cuts trace 2 s before the first stimulus 
  cutto   = stimTimes[3]-10 # and 10 s after
  PlotTrace(trace, from=cutfrom, to = cutto, extraInfo = stimulus) 
  Sys.sleep(1)
  # cut out trace
  tracei = rbind( 
    trace[ which(trace$Time==round(cutfrom))[1]:which(trace$Time==round(cutto))[1], ],
    trace[ which(trace$Time==round(cutfrom))[2]:which(trace$Time==round(cutto))[2], ]
  )
  
  tracei$Stim = paste(trace$Stim[1],stimulus,sep = "_")
  output = list(tracei)
  names(output) = stimulus
  
        # get 10 s pulse (should be the second!)
  stimulus = "p1_10s"
  cutfrom = stimTimes[3]-2 # Cuts trace 2 s before the first stimulus 
  cutto   = stimTimes[5]-10 # and 10 s after
  PlotTrace(trace, from=cutfrom, to = cutto, extraInfo = stimulus)  
  Sys.sleep(1)
  # cut out trace
  tracei = rbind( 
    trace[ which(trace$Time==round(cutfrom))[1]:which(trace$Time==round(cutto))[1], ],
    trace[ which(trace$Time==round(cutfrom))[2]:which(trace$Time==round(cutto))[2], ]
  )
  
  tracei$Stim = paste(trace$Stim[1],stimulus,sep = "_")
  output[[length(output)+1]] <- tracei
  names(output)[length(output)] = stimulus
  
        # Power 6
  # get 1 s pulse (should be the third!)
  stimulus = "p6_1s"
  cutfrom = stimTimes[5]-2 # Cuts trace 2 s before the first stimulus 
  cutto   = stimTimes[7]-10 # and 10 s after
  PlotTrace(trace, from=cutfrom, to = cutto, extraInfo = stimulus) 
  Sys.sleep(1)
  # cut out trace
  tracei = rbind( 
    trace[ which(trace$Time==round(cutfrom))[1]:which(trace$Time==round(cutto))[1], ],
    trace[ which(trace$Time==round(cutfrom))[2]:which(trace$Time==round(cutto))[2], ]
  )
  
  tracei$Stim = paste(trace$Stim[1],stimulus,sep = "_")
  output[[length(output)+1]] <- tracei
  names(output)[length(output)] = stimulus
  
        # get 10 s pulse (should be the fourth!)
  stimulus = "p6_10s"
  cutfrom = stimTimes[7]-2 # Cuts trace 2 s before the first stimulus 
  cutto   = last(trace$Time) #stimTimes[8]+60 # and 10 s after
  PlotTrace(trace, from=cutfrom, to = cutto, extraInfo = stimulus) 
  Sys.sleep(1)
  # cut out trace
  tracei = rbind( 
    trace[ which(trace$Time==round(cutfrom))[1]:which(trace$Time==round(cutto)-1)[1], ],
    trace[ which(trace$Time==round(cutfrom))[2]:which(trace$Time==round(cutto)-1)[2], ]
  )
  
  tracei$Stim = paste(trace$Stim[1],stimulus,sep = "_")
  output[[length(output)+1]] <- tracei
  names(output)[length(output)] = stimulus
  return(output)
} # only for traces with stimuli in this order p1.1s,p1.10s,p6.1s,p6.10s.
calculateslope <- function(vector) {
  slopetrace = NULL
  for( i in 2:length(vector)){
    slopei = vector[i]-vector[i-1]
    slopetrace = append(slopetrace, slopei)  
  }
  slopetrace = append(slopetrace, slopetrace[length(slopetrace)])
  return(slopetrace)
} # input a 1xN vector | output a 1xN vector with values for the slope
doFilter = 0
home = getwd()
summaryparameters = c("Genotype",
                   "record.id",
                   "electrode",
                   "stim.position",
                   "stim.power",
                   "stim.duration",
                   "peak.depol",
                   "peak.depoltime",
                   "peak.depol.slope",
                   "peakdepolslope.time",
                   "ss.depol",
                   "tau")
```


2. Create a batch folder
```{r}
batchname = "230228-analysis"
batchfolder = paste(home,batchname,sep="/")
setwd(home)
if(file.exists(batchname)==FALSE){
  dir.create(batchfolder)
}
```



3. Modify the traces in the home folder. Then the plot is divided by the stimuli. There should be only 8 stimulus points from step 1 and the order of the stimuli during the experiment must be p1-1s, p1-10s, p6-1s, p6-10s.
input   - yyy_Export.txt files in the home folder
Output  - trace, p1s1.trace, p1s1.trace... for all the files in the folder. Saved as >p#s#.csv<
```{r}
setwd(home)
list.files()
p1s1.trace = NULL
p1s10.trace= NULL
p6s1.trace = NULL
p6s10.trace= NULL
recording.id = 1
# meter en un for loop con todos los datos.
for( f in list.files()[grep(".txt",list.files())] ){ # 
  filename = f
  savename = substr( filename, 0, nchar(filename)-4 )
  savename = strsplit(savename,split = "_")[[1]][1]
  trace = read.delim(  filename  ) # import .txt file in the home folder
  #trace = read.csv("array1_Export.csv"  )
  CheckSampleRate(trace)
  
  # Save info from E1 column name
  metaData = names(trace)[grep("E1", names(trace))]
  stimulus = strsplit(metaData,"_")[[1]][3]
  genotype = strsplit(metaData,"_")[[1]][2]
  electrodeNums = NULL## Save the number of the electrode
  for(i in  names(trace)[3:ncol(trace)] ){
    electrodeNums = append(electrodeNums, as.numeric( substr(i,2, 2) ))
  }
  names(trace)[3:ncol(trace)] = electrodeNums # Make the columns' names numeric variables
  # Select just few electrodes.
  pickElectrodes = c(1,2)
  trace = trace[,c(1,2,which(names(trace)%in%pickElectrodes))]
  
  stimTimes = trace$Time[ which(  is.na(trace$Time)  ) -1]

  # normalize and gather
  trace = NormalizeBaseline(trace, normTime = 1)
  # fix voltage units to mV
  trace$mV = trace$mV * 100
  #
  ##
  ###
  #### NORMALIZE TRACE and plot
  trace$Genotype = genotype
  trace$Stim = stimulus
  trace$record.id = recording.id
  PlotTrace(trace)
  # Filter?
  answer <- readline (prompt="Filter? [y], [n]  ")
  while ( answer!="y" & answer!="n" ){
    print("No valid input, try again ")
    answer <- readline (prompt="Filter? [y], [n]  ")
  }
  if (answer == "y"){
    trace = filterTrace(trace)
    PlotTrace(trace)
  }
  print(paste(length(stimTimes)," stimuli at (s)",sep = ""))
  print(stimTimes)
        ## Save stimulus trace
  answer <- readline (prompt="Are the stim times ok? type values divided by [,] to change, [y] to continue and save or [n] to skip trace.  ")
  while ( nchar(answer)<=15 & answer!="y" ){
    print("No valid input, try again ")
    answer <- readline (prompt="Are the stim times ok? type values divided by [,] to change, [y] to continue and save or [n] to skip trace.  ")
  }
  if( nchar(answer)>15 ){
      answer = strsplit(answer,",")[[1]]
      stimTimes = as.numeric(answer)
      print("Stim times updated to ")
      print(stimTimes)
  } else if(answer == "n"){
    next
  }
      ## Segment into the different stimuli
  segments = segment.trace(trace)
  p1s1.trace = rbind(p1s1.trace,segments$p1_1s)
  p1s10.trace= rbind(p1s10.trace,segments$p1_10s)
  p6s1.trace = rbind(p6s1.trace,segments$p6_1s)
  p6s10.trace= rbind(p6s10.trace,segments$p6_10s)
      ##
      ## SAVE
  setwd(batchfolder)
  write.csv(p1s1.trace, "p1s1.csv", row.names = FALSE)
  write.csv(p1s10.trace, "p1s10.csv", row.names = FALSE)
  write.csv(p6s1.trace, "p6s1.csv", row.names = FALSE)
  write.csv(p6s10.trace, "p6s10.csv", row.names = FALSE)
  setwd(home)
      ##
  recording.id = recording.id+1
  
}
```



4. Analyze - calculate raising slope, peak depol, steady state depol, and tau.
input   -  >p#s#.csv< traces in the batch folder
output  - datasummary saved as "parameters_summary.csv" for each stimulus the calculated parameters 
  peak.depol - max depolarization
  peak.depol.slope - raising time of depolarization upon simulus
  peakdepolslope.time - time at which depol slope is max
  ss.depol - depolarization in the last second.
  tau - time at which voltage is 37% of the ss.depol after the stimulus ends.
```{r}
setwd(batchfolder)
# make for loop for all the files
files = list.files()
datasummary = NULL
for(f in files){
  data = read.csv(f)
  print(f)
  # separate stim info into columns
  data = separate(data, Stim,c("stim.position","stim.power","stim.duration"),sep = "_")
  # pick only one recording with all the available electrodes
  uniqueids = unique(cbind(data$Genotype,data$record.id,data$stim.position,data$electrode))
  for(i in 
      1:nrow(uniqueids) ){
    print(i)
  
    onepulse = data %>% dplyr::filter(  Genotype==uniqueids[i,1] & 
                                    record.id==uniqueids[i,2] &
                                    stim.position==uniqueids[i,3] &
                                    electrode==uniqueids[i,4] )
    
    savename = paste( uniqueids[i,1],"_",uniqueids[i,2],"_", onepulse$stim.power[1], onepulse$stim.duration[1], ".E",uniqueids[i,4], uniqueids[i,3], sep = "" )
    # fix time and V offset
    onepulse$Time = onepulse$Time-onepulse$Time[which(onepulse$TimeOfDay=="F1")[1]-1] # set the stimulus onset as time = 0 
    onepulse$mV = onepulse$mV - mean(na.omit(onepulse$mV[1:190]))  # set the voltage baseline as 0
plot(onepulse$Time,onepulse$mV)
      # calculate parameters
    parameters = CalculateParameters(onepulse)
# do fitting for tau?
    plot(onepulse$Time, onepulse$mV, main=savename) + 
    abline(v=onepulse$Time[which(onepulse$TimeOfDay=="F1")+1])+
    abline(v=parameters$peakdepolslope.time, col="green", lty=1)+
    abline(v=parameters$tau.abstime, col="green", lty=1)+
    abline(h=parameters$peak.depol, col="green", lty=1)+
    abline(h=parameters$ss.depol, col="red", lty=2) +
    abline(h=parameters$tau.voltage, col="red", lty=2)  
    
    print(parameters[c(5,6,7,8)])
    ## Save stimulus trace
    answer <- readline (prompt="Save plot and data? [y] to save, [n] to skip trace and not save ")
    while ( nchar(answer)!=1 ){
      print("No valid input, try again ")
      answer <- readline (prompt="Save plot and data? [y] to save, [n] to skip trace and not save ")
    }
    if( answer == "y" ){
      pdf(file = paste( savename,".pdf" , sep = "") )
        plot(onepulse$Time, onepulse$mV, main=savename) + 
        abline(v=onepulse$Time[which(onepulse$TimeOfDay=="F1")+1])+
        abline(v=parameters$peakdepolslope.time, col="green", lty=1)+
        abline(v=parameters$tau.abstime, col="green", lty=1)+
        abline(h=parameters$peak.depol, col="green", lty=1)+
        abline(h=parameters$ss.depol, col="red", lty=2) +
        abline(h=parameters$tau.voltage, col="red", lty=2)
      dev.off()
      datasummary = rbind( datasummary, 
                     cbind( onepulse[1,which( names(onepulse) %in% summaryparameters)] ,
                     parameters[which(names(parameters) %in% summaryparameters)] )
                    ) 
      write.csv(datasummary,"parameters_summary.csv",row.names = FALSE)
      
    } else if(answer == "n"){
      next
    }
  }
  files = files[-(which(files==f))]
}
```


5. Run statistics! Decide which ones you want to run

5.1 Compare Tau between genotypes
input   -   datasummary saved as "parameters_summary.csv"
output  - "datastats.csv" with mean, SEM, shapiro, and whitney-mann tests for tau data. All that plotted and saved as  "tau_OnRecordingElectrode.pdf"
```{r}
setwd(batchfolder)
# pick values where stimulus is applied on the recording electrode
onelectrode.data = datasummary %>% slice(which(datasummary$stim.position %>% substr(2,2) %>% as.integer() == datasummary$electrode))

# run statistics on the tau, 
datastats = NULL
for(g in unique(datasummary$Genotype) ){
  for(d in (datasummary%>%
            dplyr::filter(Genotype==g)%>%select(stim.duration)%>%unique() )[[1]]  ){
    for(p in (datasummary%>%
              dplyr::filter(Genotype==g&stim.duration==d)%>%select(stim.power)%>%unique() )[[1]]  ){
      #print(paste(g,d,p))
      control.tau.data = datasummary %>% 
        dplyr::filter(Genotype == "Col0" & 
                                stim.duration==d & 
                                stim.power==p) %>%
        select(tau)
      tau.data = datasummary %>% 
        dplyr::filter(Genotype == g & 
                                stim.duration==d & 
                                stim.power==p) %>%
        select(tau)
      
      tau.mean = tau.data %>% summarise(mean(tau))%>%round(2)
      n = tau.data %>% nrow()
      tau.SEM = ((tau.data %>% summarise(sd(tau)) ) / n)%>%round(2)
      tau.shapiro = shapiro.test(tau.data$tau)$p.value%>%round(2)
      tau.WM = wilcox.test(control.tau.data$tau,tau.data$tau)$p.value%>%round(2)

      datastats = rbind(datastats,
                        data.frame("Genotype"=g,
                                   "stim.duration"=d,
                                   "stim.power"=p,
                                   "mean"=tau.mean,
                                   "SEM"=tau.SEM,
                                   "N"=n, 
                                   "ShapiroTest"=tau.shapiro, 
                                   "Whitney-Mann"=tau.WM))
    }
  }
}
write.csv(datastats, "datastats.csv", row.names = FALSE)


# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_blank(), #element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.x = element_blank(), #element_line()
  panel.grid.minor.x = element_blank()) 

ggplot(datasummary, aes(`Genotype`, `tau`, color = `stim.duration`, lty = `stim.power` )) +
  geom_violin(size = 1) +
  #geom_dotplot(binaxis='y', stackdir='center', position=position_dodge(0.9),dotsize=0.5,aes(fill=`Genotype`)) +
  geom_jitter(shape=1, position=position_dodge(0.9), size = 3) +
  geom_label(data = datastats ,
             aes(label = `Whitney.Mann`, y = Inf), inherit.aes = TRUE, 
            position=position_dodge(1), vjust = 1.5 ) +
  ylab ("Tau (s)") + 
  ggtitle("Tau for stimuli on recording electrode") +
  My_Theme
ggsave("tau_OnRecordingElectrode.pdf")
```

5.2 Compare amplitude between electrodes
input   - 
output  - 
```{r}
setwd(batchfolder)
# create columns that determines which recording is of local stimulus and whichdistal
datasummary = read.csv("parameters_summary.csv")
datasummary$local.stim = NaN

datasummary = rbind( 
  datasummary %>% slice(which(datasummary$stim.position %>% substr(2,2) %>% as.integer() == datasummary$electrode)) %>% mutate(local.stim="0mm"),
  datasummary %>% slice(which(datasummary$stim.position %>% substr(2,2) %>% as.integer() != datasummary$electrode)) %>% mutate(local.stim="6mm") 
)

# work only with Col0 data for now
g = "SLAH3"
datasummary.g = datasummary%>%dplyr::filter(Genotype==g)
parameters = c("peak.depol", "peak.depol.slope", "ss.depol")
for( v in which( names(datasummary.g)%in%parameters ) ) {
  print(names(datasummary.col0)[v])
  units = "Voltage (mV)"
  if(names(datasummary.g)[v]=="peak.depol.slope"){
    units = "Slope (mV/s)"
  }
  plotName = paste(g," - ", names(datasummary.g)[v], sep = "")
  traceParamPlot <- 
    ggplot(datasummary.g, aes(`local.stim`, datasummary.g[,v], color = `stim.duration`, lty = `stim.power` )) +
      geom_violin(size = 1) + 
      #geom_dotplot(binaxis='y', stackdir='center', position=position_dodge(0.9),dotsize=0.5,aes(fill=`Genotype`)) +
      geom_jitter(shape=1, position=position_dodge(0.9), size = 3) +
      # geom_label(data = datastats ,
      #            aes(label = `Whitney.Mann`, y = Inf), inherit.aes = TRUE, 
      #           position=position_dodge(1), vjust = 1.5 ) +
      ylab (units) + 
      ggtitle(plotName) +
      My_Theme
  print(traceParamPlot)
  ggsave(paste(plotName,".pdf",sep=""),traceParamPlot )
  Sys.sleep(0.2)
}
```


