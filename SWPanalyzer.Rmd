---
title: "SWPanalyzer"
output: html_document
date: "2023-02-17"
editor_options: Code developed by Juan Camilo Barbosa-Caro
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

                                    DESCRIPTION 
        
This script helps you to manipulate and analyze raw data from electrophysiological recordings of plants made with the software LabScribe. It analyzes SWP traces and determines 6 different parameters on which statistics can be run. These parameters are:

  maxHyperpol - Maximum voltage in initial hyperpolarization stage. 
  maxDepol    - Minimum volage in the big depolarization stage
  maxRepol    - Maximum voltage in the hyperpolarization stage after depolarization
  maxHyperpol2- Amplitude of peak relative to final baseline
  bl2         - Final baseline after SWP is finished
  depDur      - Time between the followint two time points: 
                I) @ middle voltage between initial baseline and maxDepol.
                II) @ middle voltage between maxDepol and second baseline.
                  
    INPUT:
 .txt files in a folder with the following structure.
Data for one batch of recordings regardless of the amount of genotypes analyzed. All the traces from plants that grew together and were recorded in what the experimenter considers the same batch.

This raw data should be in .txt files, as exported from LabScribe, and contained in one or multiple "YYMMDD" folder(s). 
          Data about the experiment is extracted from the leaf 8 column name. So the columns that correspond to the electrodes in the original .txt file NEED to be named in the following structure for the code to manipulate it:
        Leaf 8 --         "Ez_Ly.xPG_w" 
        Leaf 13--         "Ez_Ly.x"
        Empty Electrode-- "Ez_Leer"
where:
                 z is the electrode number (1 to 4)
                 y is the leaf on which that electrode is (08 or 13)
                 x is the plant (1 or 2)
                 PG stands for Plier and Gears as the stimulation device. GL as green light
                 w is the GENOTYPE (text of any length, just avoid "_") it has to be consistent for the system to compile them all together.
                 
Example "E1_L08.1PG_Col0" 
  is the electrode one on leaf 8 of plant 1, stimulated with PG, genotype is Col0

    OUTPUT:   
    each step yields an output.
">genotype<.csv" file with modified raw data for R manipulation.
">genotype-date<" folder with a plot for every analyzed trace as 
  ">plant#.leaf#<.pdf". 
">genotype<Summary.csv" file With the amplitude, raising time, decay time. 

                                    BIASES
Traces are filtered with a Savitzky-Golay method which reduces the amplitude (by around 5mV) of traces with a very sharp spike in the peak depolarization. If there is a phenotype at very sharp depol, we are probably missing it.






                                  INSTRUCTIONS
This script should run as an R project. This will create a folder that will be your "home" directory. In this home directory you put the raw files to be analyzed (see input above). 
Along the process everything is saved in a folder that you will named in step 2.1, which will be created inside the home folder.

First thing to do: Paste a copy of the exported folders with the data from one batch of experiments.

The analysis is divided in 4 steps. Run them in order. There is a checkpoint between steps; this means that it is better if you don't close the program before finishing all the sub-steps in a step. 
If necessary to close the program and continue later, do it after finishing one full step. Remember to run step 1 every time you open the program, even if you are not starting from scratch.

         Steps:
      1. Function and library loading (Run every time you start the program)
      2. Load and convert the data.
      3. Pick and analyze summaryzed traces.
      4. Plot and run statistics on data parameters.
      
Technical guidelines. 
  - For running a chunk click on the green arrow on the right.
  - In the gear instructions at the top of the window select 
"Chunk output in console" instead of "Chunk output inline". This will show all the steps of the process in the console properly.
  - For learning more about R notebooks check the following link.
https://rmarkdown.rstudio.com/authoring_quick_tour.html
///////////////////////////////////////////////////////////////////////////////


   
                                    
1. Function and library loading

- Run this chunk once every time you start the program.
```{r}
library(ggplot2)
library(tidyr)
library(pracma)
library(signal)
library(dplyr)
library(plotrix)
Parameters = c("hyperpol.amplitude1", 
               "depol.amplitude", 
               "maxRepol", 
               "repol.amplitude", 
               "bl2",
               "depDur")

# Function for parameter finding
DataExtraction <- function(data, date){ 
  
  output <- list()
  time1 = data$Time
  ToD = data$TimeOfDay
  #determine which have info
  PlantNumber = 1
  if ( length(grep("L08",names(data))) > 1 ){
    PlantNumber = 2
  }
  # Extract info one plant at a time.
  for( n in 1:PlantNumber){
    leaf1 = paste("L08.", n, sep = "")
    leaf2 = paste("L13.",n, sep = "")
    plant1 = data[, grep(leaf1, names(data)): grep(leaf2, names(data))] # pick the columns w/ the data
    # extract info from L08 col (Stim,genotype)
    # from cols 2,3 which have 08
    info1 = names(plant1)[   grep("08", names(plant1))   ]
    # extract from that all necessary info
    stim1 = strsplit(info1,"_")[[1]][2] # separate by "_". save part with the stim. e.g. "L08.1CG"
    stim1 <- substr(stim1,6,nchar(stim1))
    genotype1 = strsplit(info1,"_")[[1]][3] # separate by "_". save part with the stim. e.g. "L08.1CG"
    # rename (Time, L08(V), L13)(V)) and tidy, and convert to numeric corresponding cols.
    plant1 = cbind(time1,plant1)
    names(plant1)[1] <- "Seconds"
    names(plant1)[   grep("08", names(plant1))   ] <- "L08"
    names(plant1)[   grep("13", names(plant1))   ] <- "L13"
    plant1 = gather(plant1, "Leaf", "V", 2:3)
    plant1$plant = n
    plant1$Seconds = as.numeric(plant1$Seconds)
    plant1$`V` = as.numeric(plant1$`V`)*100
    plant1$Genotype = genotype1
    plant1$Stim = stim1
    plant1$Date = date
    plant1$DayTime = ToD
    plant1$Plot = "No"
    
    plant1 = list(plant1)
    output <- append(output,plant1) 
    names(output[n]) <-  paste("plant",n,sep = "")
  }
  
  return(output)
}###  LabScribe into data frame. PlantNumber= 1 or 2 per trace (Should make it 4, for each electrode)
AmIDone <- function(file){
  CheckTraces = read.csv(file) 
  pendingList = c()
  if( nrow(  dplyr::filter(CheckTraces, Plot=="No" ))>0  ){
    print( paste("You still need to analyse these plants for ",
                 file, ":", sep = "") )
    pendingTraces = dplyr::filter(CheckTraces, Plot=="No" )
    for(i in unique(pendingTraces$Date) ){
      missingDates = i
      ids = unique( pendingTraces$id[which(pendingTraces$Date==i)] )
      print( paste(i,ids,sep = "-")  )
      pendingList = append(pendingList,paste(i,ids,sep = "-") )
    }
  } else { 
    print( paste("You're done with", file, "!!!") ) 
    }
  return(c(pendingList))
  
}
findSWPvalues <- function(trace, plant){
  ### Set reference time 0 when stimulus is applied: either at the first F1 value or or at the first maximum value.
  if(length( which( is.na(trace)) ) > 0 ){
    stimFrames =   which( is.na(trace))
    if( length( which( is.na(trace))) > 2 ) {
      stimFrames =  which( is.na(trace))[c(1,3)]
    }
    # Pick the first NaN (or F1 in DayTime column) for plant 1, and the 3rd NaN for plant 2
    if( plant == 1){
      stimFrame = stimFrames[1] ### Determines the stimulus frame by finding the first NaN. Which is when the pedal is pressed.
    }
    if( plant == 2){
      stimFrame =   stimFrames[length(stimFrames)]  ### Determines the -later- stimulus frame for plant 2
    }
    
  } else {
    stimFrames =  c(90,95)
    # Pick the first NaN (or F1 in DayTime column) for plant 1, and the 3rd NaN for plant 2
    if( plant == 1){
      stimFrame = stimFrames[1] ### Determines the stimulus frame by finding the first NaN. Which is when the pedal is pressed.
    }
    if( plant == 2){
      stimFrame =   stimFrames[2]  ### Determines the -later- stimulus frame for plant 2
    }
  }
  
  
  
  
  ### Filter signal
  trace[which(trace < -150)] = trace[1] # Make extreme values equal baseline. It's when the electrode looses contact.
  # smooth with Savitzky-Golay filter. 
  # n is the amount of point befor/after the nth point to be averaged
  # p is the filter order. Dont know what that is.
   trace = sgolayfilt(na.omit(trace) , p = 1, n = 3)
  # trace = na.omit(trace) ## if not filtering, just omit NaNs
  # Check trace (for debugging)
  plot(trace, type = "l")+
    abline(v=stimFrame) 
  


                        ### Initial baseline
  bl = mean(trace[ 1:(stimFrame-2)]) # average from 0 to before stimFrame
  
  
  
  ### Find peak depolarization
  maxDepol = min(   na.omit( trace[ stimFrame:length(trace) ] )   ) # find peak depol. It's extracellular recording, so depol goes to negative
  
  depolFrame = which(trace == maxDepol) # Find frame at maximum  
  
  
  
                        ### hyperpol.amplitude1
  ### Find peak of first hyperpolarization between stimulus and depol peak
  maxHyperpol = max(  na.omit(trace[ (stimFrame-10) : which(trace==maxDepol) ])   )
  hyperpolFrame =  which(trace == maxHyperpol)       
  hyperpol.amplitude1 = maxHyperpol-bl
  
  
  
                        ### depol.amplitude
  depol.amplitude = maxDepol - abs(maxHyperpol) # Calculate max depol from the peak of hyperpol rather than from the initial baseline
  
  
  
  
                        ### maxDepol/2 frame
  ### Find Half maximum to depolarization peak     
  halfDepol =  (maxDepol - bl) / 2 # Find halfmax Voltage
    # to find half max frame, substract the halfMax V from the trace and pick the closest to 0.
    # focus on the chunk between stim and max
  depolTrace = trace[ (stimFrame+1) : depolFrame  ] 
  HalfDepolframe = min (
    which (  abs((depolTrace)-halfDepol ) == min( abs((depolTrace)-halfDepol))  )  ## Find the time at Halfdepol
  ) #+ stimFrame 
  
  
  
  
                          ### second baseline
  ### Find second baseline i.e. after repolarization
  bl2 = mean(trace[   (length(trace)-60): length(trace)   ])
  
  
  
  
                        ### repol.amplitude
    # focus on repolarization part of the trace
  repolTrace = trace[(depolFrame+1):length(trace)]
  maxRepol = max(repolTrace) # maximum repolarization
  maxRepolframe = which(repolTrace == maxRepol)+depolFrame
  repol.amplitude = maxRepol-bl2 # Find hyperpolarization amplitude in the recovery phase
  # former maxHyperpol2
  
  
                        ### maxRepol/2 frame
  halfRepol = bl2 + (maxDepol - bl2)/2# the voltage value  FFIX THIS
  halfRepolframe = which( abs(repolTrace-halfRepol) == min (abs(repolTrace-halfRepol))  )   + depolFrame - stimFrame
  

  
                            ### Depolarization duration
  #Time from halfmax raise and decay        
  depDur = halfRepolframe - HalfDepolframe
  
  
  #return all these
  SWPvalues = data.frame(
  bl,
  maxDepol,
  hyperpol.amplitude1,
  maxHyperpol,
  HalfDepolframe,
  depol.amplitude,
  halfRepolframe,
  maxRepol, 
  repol.amplitude,
  bl2,
  depDur,
  stimFrame
  )
  return( list(trace, SWPvalues))
  
}
trimTrace <-function(trace, second){
  trimFrame = which(trace$Seconds == second)
  trace = trace[1:trimFrame,]
  plot(trace$V, type="l")
  return(trace)
}
plotAndAnalyze <- function(genotypeFile){
  # Load file newly
  ALLtraces = read.csv( genotypeFile )
  # Load summary file if exists.
  if( file.exists( paste(savename,"Summary.csv",sep = "")) )  {
    fTraceSummary = read.csv( paste(savename,"Summary.csv",sep = "") )
  } else {
    fTraceSummary = NULL
  }
  # start w/ emptying variables
  Date = c()
  Stim = c()
  id = c()
  Leaf = c()
#### filter to get to one single plant
  subSet0 = dplyr::filter(ALLtraces,Plot == "No") 
  for (datei in unique(subSet0$Date)){ # pick one date
    subSet1 = dplyr::filter(subSet0, Date == datei)
    # create folder if it doesn't exist
    if( dir.exists(paste( savename,"-",datei,sep = ""))==FALSE ){
      dir.create(paste( savename,"-",datei,sep = ""))
    }
     for(stimi in unique(subSet1$Stim) ) { # pick one stimulus form
      subSet2 = dplyr::filter(subSet1, Stim == stimi) 
      for(IDi in unique(subSet2$id) ) { # pick one id
        subSet3 = dplyr::filter(subSet2, id == IDi) 
        for (leafi in unique(subSet3$Leaf) ){ # pick a leaf
          # single trace to be analyzed
          trace = dplyr::filter(subSet3, Leaf == leafi)
          
          ### Check trace to decide if needs trimming of final part
          
          
          plot(trace$V, type="l")
          
          
          
          # Trim or not
          answer <- readline (prompt="Trim trace? Second+ENTER, just ENTER to skip trimming, or >n< for skipping & erasing trace  ")
          if(nchar(answer)>0){
            if(answer == "n"){
              print("Trace not saved")
              #### Erase the trace is not saved!
              traceIndeces = which(ALLtraces$Date == datei & 
                                     ALLtraces$Stim==stimi &
                                     ALLtraces$id == IDi &
                                     ALLtraces$Leaf == leafi )
              ALLtraces = ALLtraces[-traceIndeces,]
              write.csv(ALLtraces, paste(savename,".csv",sep = ""), row.names = FALSE)
              traceIndeces = c()
              
              break # this should go to the next leaf
              
            } else if( !is.na( as.numeric(answer) )) {
              trace = trimTrace(trace, answer)
            } else {
              print("No valid input ")
              answer <- readline (prompt="Trim trace? Second+ENTER, just ENTER to skip trimming, or >n< for skipping & erasing trace  ")
            }
            
          }  
      
          
  ### FUNCTION TO CALCUATE PARAMETERS         
          SWPanalysis = findSWPvalues(trace$V, trace$plant[1])
          trace = na.omit(trace)
          # Save trace and values independently
          trace$V = SWPanalysis[[1]]
          SWPvalues = SWPanalysis[[2]]
          trace$Seconds = trace$Seconds - SWPvalues$stimFrame  # Make time at stimulus frame = 0
  
          
  
  ### PLOT!        
          plotTitle = paste(IDi,leafi, sep = ".")
          
            plot(x = trace$Seconds, y = trace$V, type = "l", main = plotTitle ) +
            abline(h = SWPvalues$bl, col="black", lty = 2) +
            abline(v = SWPvalues$HalfDepolframe, col="red") +
            abline(v = SWPvalues$halfRepolframe, col="green") +
            abline(h = SWPvalues$maxDepol, col = "red") +
            abline(h = SWPvalues$maxHyperpol, col = "blue") +
            abline(h = SWPvalues$maxRepol, col = "blue") +
            abline(h = SWPvalues$bl2, col="green", lty = 2) +
            abline(v = 0, col="black", lty = 2)
  
           
            print(paste(datei,IDi,stimi,leafi,sep = "-"))
            print(SWPvalues)
          
          
  #### Save or not
          if(SWPvalues$depol.amplitude > -10){
            answer <- readline (prompt="NO RESPONSE! save as failed trace? [y];[n]    ")
            if(answer == "y"){
              SWPvalues$depDur = NA
              plotTitle = paste("FAIL",plotTitle, sep = "-")
            }
          } else {
            answer <- readline (prompt="Press [y] to save; [n] to skip    ")
          }
            
            
          
          while ( is.null(answer)==FALSE ){ #answer != "y" || answer != "n"
            traceIndeces = which(ALLtraces$Date == datei & 
                                   ALLtraces$Stim==stimi &
                                   ALLtraces$id == IDi &
                                   ALLtraces$Leaf == leafi )
            if (answer == "y") {
              # put in dataframe
              Date = datei
              Stim = stimi
              id = IDi
              Leaf = leafi
              
              # save data
              fTraceSummary = rbind(fTraceSummary, cbind(Date,Stim,id,Leaf,SWPvalues) )
                ## get rid of infinite values
              for(i in 5:ncol(fTraceSummary)){
                fTraceSummary[which(fTraceSummary[,i] == Inf),i] = NaN
              }
              write.csv(fTraceSummary, paste(savename,"Summary.csv",sep = ""), row.names = FALSE)
              
              # save plot
              pdf(file = paste( savename,"-",datei,"/", plotTitle, ".pdf" , sep = "") )
              plot(x = trace$Seconds, y = trace$V, type = "l", main = plotTitle) +
                abline(h = SWPvalues$bl, col="black", lty = 2) +
                abline(v = SWPvalues$HalfDepolframe, col="red") +
                abline(v = SWPvalues$halfRepolframe, col="green") +
                abline(h = SWPvalues$maxDepol, col = "red") +
                abline(h = SWPvalues$maxHyperpol, col = "blue") +
                abline(h = SWPvalues$maxRepol, col = "blue") +
                abline(h = SWPvalues$bl2, col="green", lty = 2) +
                abline(v = 0, col="black", lty = 2) 
              dev.off()
              
              # update database of traces. label the plotted as plotted.
              # Set plot status to YES
              ALLtraces$Plot[traceIndeces] = "Yes"
              write.csv(ALLtraces, paste(savename,".csv",sep = ""), row.names = FALSE)
            
              break
            }
            else if (answer == "n") {
              print("Trace not saved")
              #### borrar del archivo si no se guarda!
              ALLtraces = ALLtraces[-traceIndeces,]
              write.csv(ALLtraces, paste(savename,".csv",sep = ""), row.names = FALSE)
              traceIndeces = c()
  
              break
            }
            else {
              print("Not valid input")
              answer <- readline (prompt="Press [y] to save; [n] to skip")
              
            }
          } 
        }
      }
    }
  }
  return(fTraceSummary)
}


home = getwd()
print("Continue with step 2.1 or where you left")
```
///////////////////////////////////////////////////////////////////////////////





2. Convert the data from Labscribe into dataframe for analysis.
Create a folder with the name of your election and save there the modified data as >genotype<.csv files. 

2.1. Write your folder's name in the batch variable

                             EDIT THE FOLDER NAME HERE
```{r}
foldername = "almt5.1-221114.15.16-2.0" # Replace the text in "" with the name you want your folder to have.
batchFolder = paste(home,foldername,sep="/")
print("Continue with step 2.2")
```

2.2. Run this to extract the data and save it in a folder with the name previously given. Ignore the errors that are shown at the end. This is due to the pedal (F1) marks in the traces. Check that you have the >genotype<.csv files in the folder that you created in the last step and continue with step 3.
If this stops with an error instead of a success message, the file last printed does not have the proper formating. Check that column names fit the INPUT conditions above.
```{r}
## Load file names
setwd(home)
initialFiles = list.files()
dir.create(batchFolder)

# Loop through all the date-named folder containing the raw data. Saves and prints all the traces found.
files = c()
for (f in list.files()){
  
  ################ Check if it's a folder with content
  if( length(list.files(f)) != 0 ){ 
    files = list.files(f)[  grep(".txt",  list.files(f))  ]
  } 
  else if(length(list.files(f)) == 0) next # skip to next file if doesn't have content
  
  
  
  ################ Loop through all files in folder
  for (i in files){
    print( paste(f,i,sep="_") )
    setwd(paste(home,f,sep = "/")) # go into folder with the files to extract
    traceList = DataExtraction( read.delim(i), f )# load .txt file returns list with all plants recorded in file.

    
    # Save traces to files. Sort by genotype -in another folder-
    for ( p in 1:length(traceList) ){ # loop through plants in list of traces
      setwd(batchFolder) # go to dir specific to that batch
      
      
    
      # if genotype file of plant "p" exists, open it
      
      
      
      findFile = paste(traceList[[p]]$Genotype[1], ".csv", sep = "")
      if ( length( grep( findFile , list.files( ), fixed = TRUE)) == 1 ){ # looks for EXACT match of genotype.csv i.e., Col0 =! Col0.1
        genotypeData = read.csv( list.files(batchFolder)[ grep(findFile, list.files(batchFolder), fixed = TRUE )] )  
       
        
         # create new, consecutive id number for plants recorded the same date.
        if( length(grep(f, genotypeData$Date)) > 0 ){ # if genotype exists and also date
          traceList[[p]]$id = as.numeric(genotypeData %>% dplyr::filter(Date == f) %>% dplyr::summarise(max(id)) + 1 ) 
        }
        
        
        # if the genotype exists but not the date
        else if(length(grep(f, genotypeData$Date)) == 0){
          traceList[[p]]$id = 1
        } 
       
        genotypeData = rbind(genotypeData, traceList[[p]]) # append plant "p" to genotype database
      }
      
      
      
      
      # else, no genotype file yet
      if ( length( grep( paste(traceList[[p]]$Genotype[1], ".csv", sep = ""), list.files( ), fixed = TRUE)) == 0 ){  # looks for EXACT match of genotype. i.e., Col0 =! Col0.1
        traceList[[p]]$id = 1
        genotypeData = traceList[[p]] # create new file
      }
      
      
      # Down sample to 1Hz if the traces were saved in 10Hz
    newIndeces = sort( 
      c( which(genotypeData$Seconds%%1==0), which(is.na(genotypeData$Seconds)==TRUE) ), 
      decreasing = FALSE)
    genotypeData = genotypeData[newIndeces,]
      # Fix units on voltage to milivolts 
      
    
      # save i    
      write.csv(genotypeData, paste( batchFolder,"/",traceList[[p]]$Genotype[1],".csv",sep = "" ), row.names = FALSE )
      print(paste( f, i, traceList[[p]]$Genotype[1], traceList[[p]]$DayTime[1], sep = " - ") )
    } # finish saving all traces "p" in file "i"
  } # finish opening all files in folder "f"
  
  setwd(home)
}
print("Success! continue with step 3.1")
```
///////////////////////////////////////////////////////////////////////////////





3. Load the data
Make sure you have the batch folder in the home directory, as created in step 2.2. 
Also make sure to have written and run step 2.1 with the proper batch folder name.

 
3.1. Check traces to be done

- Run to see how many and which traces you have to analyze.
```{r}
## Loop through the genotypes recorded in that batch
files2analyze = list.files(batchFolder)[grep(".csv", list.files(batchFolder))]
pendingFiles = list()
setwd(batchFolder)
for(g in files2analyze) {
  pendingFiles[[g]] =c( AmIDone( g ) ) 
}
save(pendingFiles, file="batchTraces.RData")
setwd(home)
print("Continue with step 3.2")
```


3.2. Pick and analyze traces

This function will show you a trace and ask you whether to 
  trim and save,  (input the second at which to trim, then ENTER)
  to only save    (just press enter) or
  to erase        (input n, then ENTER)
  
- Run as many times as required until the step 3.3 tells you are done. This should run through all traces in the ideal case, but will stop in case some trace is damaged. The easiest thing to do is to re-run this chunk and skip/erase the trace when the program first asks you what to do. 
```{r}
### reset plot record of a file if needed ####

# fileName = "almt5.3.csv"#names(pendingFiles[f])
# genotypeData = read.csv( fileName )
# genotypeData$Plot="No"
# write.csv(genotypeData, fileName, row.names = FALSE )

#####

setwd(batchFolder)

## Function that loops through all the non-analyzed traces of the loaded 
for(f in names(pendingFiles)){
  savename = f
  savename = substr( savename, 1,nchar(savename)-4)
  print( paste("Analyzing ", savename, sep = "") )
## FUNCTION that loads, plots, and calculates parameters. 
  traceSummary = plotAndAnalyze( f )
}
```

3.3.
Check status of analysis
```{r}
## Update pending files.
setwd(batchFolder)
for(g in names(pendingFiles) ) {
  pendingFiles[[g]] =c( AmIDone( g ) ) 
}
if(length(pendingFiles) == 0){
  print("You are done! continue to step 4")
  unlink("batchTraces.RData")
  
} else {
  save(pendingFiles, file="batchTraces.RData")
  print("Run again chunk 3.2")
}
setwd(home)
```
///////////////////////////////////////////////////////////////////////////////




4. Plot and run statistics on data parameters.

4.1.
Plot and save one violin plot for each parameter quantified including all genotypes recorded.
```{r}

### OMIT 0 from FAILED traces
# data is duplicated



setwd(batchFolder)
# Open all the "Summary" files in the folder.
SummaryData = NULL
for( i in grep("Summary", list.files()) ){
  data = read.csv( list.files()[i] )
  data$Genotype = substr(list.files()[i], 1, nchar(list.files()[i])-11 )
  SummaryData = rbind(SummaryData, data )
}


# find mean and SEM, shapiro test for each genotype
    # also
# Non-parametric test comparing each mutant to Col0 for this batch. 
# Mann-whitney U test (the wilcox.test) & Kruskal-Wallis
StatsData = NULL
for ( g in unique(SummaryData$Genotype) ){ # pick genotype
  for(l in unique(dplyr::filter(SummaryData, Genotype==g)$Leaf) ){ # pick leaf for genotype g.
    for( v in which( names(SummaryData)%in%Parameters ) ) { # loop through columns
      data = dplyr::filter(SummaryData, Genotype==g & Leaf==l)[,v] %>% na.omit()
      print(paste(g,l, names(SummaryData)[v] ))
      n = length( data )
      average = mean( data )
      sem = std.error( data )
      # run normality shapiro test
      if(length( data ) < 3 ){
        Shapiro = 0
      } else {
        Shapiro = round( shapiro.test( data )$p.value, 3)
      }
      
      # Mann-Whitney U test.
      WM =  wilcox.test( x= data,
                   y=dplyr::filter(SummaryData,Genotype=="Col0" & Leaf==l)[,v],
                   paired = FALSE,
                   alternative = "t", # alternative hypothesis is two sided.
                   mu = 0 ) # Ho is that both samples distribution location don't shift. i.e. shift by mu=o
      WM = round( WM$p.value, 3)
      
      # Kruskal-wallis test
      if(g=="Col0"){ # Make it 1 if Col0 is compared to itself
        KW = 1
      } else {
        dataKW = dplyr::filter(SummaryData, Genotype==g | Genotype=="Col0" & Leaf==l)[,c(v,which(names(SummaryData)=="Genotype"))]
      KW = kruskal.test( dataKW[,1] ~ Genotype, data = dataKW)
      KW = round(KW$p.value,3)
      }
      
      
      StatsData = rbind(StatsData, data.frame(g,l,names(SummaryData)[v],average,sem, n, Shapiro, WM, KW ))
    }
  } 
}
names(StatsData) <- c("Genotype","Leaf","Variable", "Mean", "SEM", "N", "ShapiroTest", "Whitney-Mann", "Kruskal-Wallis")
write.csv(StatsData, paste(paste(unique(SummaryData$Date),collapse="."),"-basicStats.csv",sep = "" ) )




#############################


# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_blank(), #element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.x = element_blank(), #element_line()
  panel.grid.minor.x = element_blank()) 

for( v in which( names(SummaryData)%in%Parameters ) ) {
  units = "Voltage (mV)"
  if(names(SummaryData)[v]=="depDur"){
    units = "Time (s)"
  }
  plotName = paste(paste(unique(SummaryData$Date),collapse="."), "-",
                   names(SummaryData)[v], sep = "")
  
  
  traceParamPlot <- ggplot(SummaryData, aes(`Genotype`, SummaryData[,v], color = `Leaf`)) +
  geom_violin() +
  geom_jitter(shape=16, position=position_dodge(1)) +
    
  geom_label(data = dplyr::filter(StatsData, Variable == names(SummaryData)[v]) ,
             aes(label = `Whitney-Mann`, y = Inf), inherit.aes = TRUE, 
             position=position_dodge(1), vjust = 1.5 ) +
             #aes(x = `Genotype`, y = 1, label = `Whitney-Mann`,  color = `Leaf`) ) +
    
  ylab (units) + 
  #xlab ("Time (s)") + 
  #labs(color = "Leaf") +
  ggtitle(plotName) +
  My_Theme
  print(traceParamPlot)
  
  ggsave(paste(plotName,".pdf",sep=""),traceParamPlot )
  Sys.sleep(2)
}



setwd(home)
print(" Continue with step 4.2")
```




4.2.
Plot the mean of all aligned traces. Saves the plots as PDFs in the batch folder
```{r}
setwd(batchFolder)
# Violin plot for each parameter calculated
My_Theme =  theme(
  axis.text.x = element_text(color = "black", size = 20, angle = 0, hjust = 0.5, vjust = 0, face = "plain"),
  axis.text.y = element_text(color = "black", size = 20, angle = 0, hjust = 0 , vjust = 0.5, face = "plain"),
  axis.title.x = element_text(color = "black", size = 25, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #element_blank(), #element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), #
  axis.title.y = element_text(color = "black", size = 25, angle = 90, hjust = 0.5, vjust = 1, face = "plain"),
  plot.title = element_text(color = "black", size = 30, angle = 0, hjust = 0.5, vjust = 0, face = "plain"), # element_blank(), 
  legend.text = element_text(size = 20),
  legend.title = element_text(hjust = 0.1, size = 20),
  panel.grid.major.y = element_line(), # element_blank()
  panel.grid.minor.y = element_line(),
  panel.grid.major.x = element_line(), #element_line()
  panel.grid.minor.x = element_blank()) 
# loop betwee genotypes
for(g in  unique(StatsData$Genotype)){
  genotypeData <-  read.csv(paste(g,".csv",sep = "")) %>% unite("id",id,plant,Date,sep = "_")
  # Organize T-V1-V2...Vn
  for (l in unique(genotypeData$Leaf)){
    Leafdata = genotypeData %>% dplyr::filter(Leaf==l)
    leafn = StatsData %>% filter(Genotype == g, Leaf == l) %>% summarize(mean(N)) %>% as.numeric
    meanPlot =data.frame("Seconds"=c(seq(-30,0),seq(1,270))) 
    for (i in unique(Leafdata$id) ){
      vCol = Leafdata %>% dplyr::filter(Leaf==l, id==i) %>% select(V) # pick a single V vector
      # get the frame at which max depol happens for that trace.
      mleaf = l
      mid = strsplit(i,split = "_")[[1]][1]
      mplant = strsplit(i,split = "_")[[1]][2]
      mdate = strsplit(i,split = "_")[[1]][3]
      stimFrame = SummaryData %>% 
        dplyr::filter(Date==mdate,id==mid,Leaf==mleaf, Genotype==g)%>%
        summarise(stimFrame+HalfDepolframe) %>% as.numeric()
          #print(stimFrame)
        # align to half max
      # Cut the trace 30s before half max and 270s after.
      vCol = data.frame(V = vCol$V[(stimFrame-30):(stimFrame+270)] )
          #plot(x = meanPlot$Seconds,y = vCol$V)
      names(vCol) = i
      meanPlot = cbind(meanPlot,id=vCol)
      
    }
    meanPlot$Mean = rowMeans(meanPlot)
    meanPlot$pSEM = meanPlot$Mean + 
      (apply(meanPlot,1,na.omit(sd))/rowSums(!is.na(meanPlot))  )
    meanPlot$nSEM = meanPlot$Mean -
      (apply(meanPlot,1,na.omit(sd))/rowSums(!is.na(meanPlot))  )
    
    meanOnly = data.frame(Seconds=meanPlot$Seconds, 
                          Mean=meanPlot$Mean,
                          pSEM=meanPlot$pSEM,
                          nSEM=meanPlot$nSEM)
    # Plot mean and SEM
    mplot <- ggplot(na.omit(meanOnly), aes(x = Seconds))+
      geom_line(aes(y = Mean)) +
      geom_line(aes(y = pSEM),alpha=0.5,color="blue") +
      geom_line(aes(y = nSEM),alpha=0.5,color="blue") +
      ylab ("mV") + 
      xlab ("Time (s)") + 
      ylim (-100,40) +
        #labs(color = "Leaf") +
      ggtitle( paste(g,"-",l," n=",leafn," mean±SEM", sep = "") ) +
      My_Theme
    print(mplot)
    Sys.sleep(2)
    ggsave( paste("Mean-",g,"-",l,".pdf",sep = ""), mplot )
  }
}



  





setwd(home)
```
///////////////////////////////////////////////////////////////////////////////







Under construction. Plot all the traces and the average on top.
```{r}
#### Gather dataframe for plotting
meanPlot=gather(meanPlot,key = "id", value = "V",2:ncol(meanPlot))


# plot all the traces and the mean on top ### I AM HERE!!!
ggplot( na.omit(dplyr::filter(meanPlot,id!="Mean"&id!="pSEM"&id!="nSEM")) , 
       aes(x=Seconds,y=V,color=id))+
  geom_line(alpha=0.5) + # AAAAAAAASJKFDSAJKDFASJKDAFSJKFJKD
  geom_line( aes(x=dplyr::filter(meanPlot,id=="Mean")$Seconds, y=dplyr::filter(meanPlot,id=="Mean")$V ) )

```


